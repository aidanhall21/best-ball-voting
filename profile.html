<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>User Profile - Draft or Pass</title>
  <link rel="stylesheet" href="style.css" />
  <script defer src="header.js"></script>
  <script defer src="script.js"></script>

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="/favicon_io/site.webmanifest">
  <link rel="shortcut icon" href="/favicon_io/favicon.ico">

  <!-- Social share metadata -->
  <meta property="og:title" content="User Profile - Draft or Pass">
  <meta property="og:description" content="View user profile, achievements, and voting history">
  <meta property="og:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://draftrpass.com/profile.html" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="User Profile - Draft or Pass">
  <meta name="twitter:description" content="View user profile, achievements, and voting history">
  <meta name="twitter:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta name="twitter:image:alt" content="Draft or Pass - User Profile page preview">

  <!-- Cloudflare Web Analytics -->
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "059f1f1236dc4f709c203129c35b24c2"}'></script>
  <!-- End Cloudflare Web Analytics -->

  <style>
    .profile-header {
      background: #161b22;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      max-width: 800px;
      width: 100%;
      position: relative;
    }

    .profile-header h2 {
      margin: 0 0 10px 0;
      font-size: 24px;
    }

    .profile-header .no-display-name {
      color: #8b949e;
      font-style: italic;
    }

    .profile-header p {
      color: #8b949e;
      margin: 5px 0;
    }

    .profile-header .login-method {
      display: inline-block;
      padding: 4px 12px;
      background: #30363d;
      border-radius: 12px;
      font-size: 14px;
      margin-top: 10px;
    }

    .achievements-section {
      background: #161b22;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      max-width: 800px;
      width: 100%;
    }

    .achievements-section h3 {
      margin: 0 0 20px 0;
      font-size: 20px;
    }

    .coming-soon {
      color: #8b949e;
      font-style: italic;
      font-size: 14px;
      padding: 20px;
      text-align: center;
      background: #1c2128;
      border-radius: 8px;
    }

    .uploads-section {
      background: #161b22;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 50px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      max-width: 800px;
      width: 100%;
    }

    .uploads-section h3 {
      margin: 0 0 20px 0;
      font-size: 20px;
    }

    .uploads-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }

    .uploads-table th,
    .uploads-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #30363d;
    }

    .uploads-table th {
      font-weight: 600;
      color: #8b949e;
      font-size: 14px;
    }

    .uploads-table tr:hover {
      background: #1c2128;
    }

    .uploads-table td {
      font-size: 14px;
    }

    /* Right-align Count column (3rd column) */
    .uploads-table th:nth-child(3),
    .uploads-table td:nth-child(3) {
      text-align: right;
    }

    .edit-username {
      background: transparent;
      border: none;
      color: #58a6ff;
      cursor: pointer;
      padding: 2px 6px;
      font-size: 12px;
      border-radius: 4px;
    }

    .edit-username:hover {
      background: rgba(88, 166, 255, 0.1);
    }

    .username-select {
      background: #30363d;
      color: #f0f6fc;
      border: 1px solid #58a6ff;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 14px;
      max-width: 150px;
    }

    .logout-btn {
      background: #da3633;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      margin-top: 20px;
      transition: background 0.2s;
    }

    .logout-btn:hover {
      background: #b91c1c;
    }

    .edit-display-name {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      border: none;
      color: #58a6ff;
      cursor: pointer;
      padding: 2px 6px;
      font-size: 14px;
      border-radius: 4px;
      opacity: 0.8;
    }

    .edit-display-name:hover {
      background: rgba(88, 166, 255, 0.1);
      opacity: 1;
    }

    .display-name-input {
      background: #30363d;
      color: #f0f6fc;
      border: 1px solid #58a6ff;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 20px;
      max-width: 300px;
      margin-right: 8px;
    }

    .save-display-name {
      background: #238636;
      color: white;
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .save-display-name:hover {
      background: #2ea043;
    }

    .cancel-display-name {
      background: #21262d;
      color: #f0f6fc;
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 4px;
    }

    .cancel-display-name:hover {
      background: #30363d;
    }

    @media (max-width: 768px) {
      .profile-header,
      .achievements-section,
      .uploads-section {
        border-radius: 0;
        padding: 20px;
      }

      .uploads-table th,
      .uploads-table td {
        padding: 8px;
      }
    }

    /* --- Tab styles for Uploads / Vote Results --- */
    .tab-header {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }

    .tab-btn {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s, color 0.2s;
    }

    .tab-btn:hover {
      background: #30363d;
    }

    .tab-btn.active {
      background: #58a6ff;
      color: #fff;
      border-color: #58a6ff;
    }

    .tab-content {
      width: 100%;
    }

    /* Right-align numeric columns */
    .vote-results-table td:nth-child(4),
    .vote-results-table td:nth-child(6),
    .vote-results-table th:nth-child(4),
    .vote-results-table th:nth-child(6) {
      text-align: center;
    }

    /* Center-align rating column */
    .vote-results-table td:nth-child(2),
    .vote-results-table th:nth-child(2) {
      text-align: center;
    }

    /* Left-align Contest column */
    .vote-results-table td:nth-child(3),
    .vote-results-table th:nth-child(3),
    .vote-results-table td:nth-child(5),
    .vote-results-table th:nth-child(5) {
      text-align: left;
    }

    /* Column width optimizations */
    .vote-results-table th,
    .vote-results-table td {
      padding: 8px;
      white-space: nowrap;
    }

    /* Team column - allow wrapping but with min/max width */
    .vote-results-table th:first-child,
    .vote-results-table td:first-child {
      min-width: 100px;
      max-width: 200px;
      white-space: normal;
      width: 25%;
    }

    /* Rating column - fixed width for consistency */
    .vote-results-table th:nth-child(2),
    .vote-results-table td:nth-child(2) {
      width: 80px;
      min-width: 80px;
    }

    /* Contest column - allow wrapping with max width */
    .vote-results-table th:nth-child(4),
    .vote-results-table td:nth-child(4) {
      max-width: 150px;
      white-space: normal;
      width: 20%;
    }

    /* W/L columns - minimal fixed width */
    .vote-results-table th:nth-child(5),
    .vote-results-table td:nth-child(5),
    .vote-results-table th:nth-child(6),
    .vote-results-table td:nth-child(6) {
      width: 50px;
      min-width: 50px;
    }

    /* Win % column - slightly wider fixed width */
    .vote-results-table th:last-child,
    .vote-results-table td:last-child {
      width: 70px;
      min-width: 70px;
    }

    /* Smaller rating boxes for tables (match leaderboard size) */
    .vote-results-table .rating-box {
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 12px;
      min-width: 24px;
      border: 1px solid;
      margin: 0;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .vote-results-table {
        font-size: 14px;
      }

      /* Make table container scrollable horizontally */
      #voteResultsContent {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      }

      /* Ensure table takes full width */
      .vote-results-table {
        min-width: 600px; /* Ensure all columns are visible when scrolling */
      }

      .vote-results-table th,
      .vote-results-table td {
        padding: 6px 4px;
      }

      /* Adjust column widths for mobile */
      .vote-results-table th:first-child,
      .vote-results-table td:first-child {
        min-width: 80px;
        max-width: 120px;
      }

      .vote-results-table th:nth-child(4),
      .vote-results-table td:nth-child(4) {
        max-width: 100px;
      }

      /* Make View Team, View Votes, and Select Team buttons smaller and fit on one line */
      .view-team-btn, 
      .view-votes-btn,
      .select-team-btn {
        padding: 2px 4px;
        font-size: 10px;
        margin-right: 2px;
        white-space: nowrap;
        display: inline-block;
        width: calc(50% - 2px); /* Split width evenly minus margin */
      }

      /* Remove right margin from last button */
      .view-votes-btn,
      .select-team-btn {
        margin-right: 0;
      }

      /* Container for buttons to ensure they stay on one line */
      .vote-results-table td:first-child {
        white-space: nowrap;
        padding: 6px 2px;
        width: auto;
        min-width: 120px; /* Ensure enough space for both buttons */
      }
    }

    /* Styling for View Team and View Votes buttons */
    .view-team-btn, .view-votes-btn {
      background: #30363d;
      color: #c9d1d9;
      border: 1px solid #21262d;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-right: 4px;
      transition: background 0.2s;
      display: inline-block;
      white-space: nowrap;
    }

    .view-team-btn:hover, .view-votes-btn:hover {
      background: #58a6ff;
      color: #fff;
    }

    /* Styling for Select Team button */
    .select-team-btn {
      background: #238636;
      color: #fff;
      border: 1px solid #1f883d;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 4px;
      transition: background 0.2s;
      display: inline-block;
      white-space: nowrap;
    }

    .select-team-btn:hover {
      background: #2ea043;
      color: #fff;
    }

    /* Nominated state styling */
    .select-team-btn.nominated {
      background: #da3633;
      border-color: #f85149;
    }

    .select-team-btn.nominated:hover {
      background: #f85149;
      color: #fff;
    }

    /* Disabled state styling for when nominations are closed */
    .select-team-btn:disabled,
    .select-team-btn.disabled {
      background: #6e7681 !important;
      border-color: #545d68 !important;
      color: #8b949e !important;
      cursor: not-allowed !important;
      opacity: 0.6;
    }

    .select-team-btn:disabled:hover,
    .select-team-btn.disabled:hover {
      background: #6e7681 !important;
      color: #8b949e !important;
      transform: none !important;
      box-shadow: none !important;
    }

    /* Ensure buttons appear side by side in tournament teams table */
    .uploads-table.vote-results-table td:first-child {
      white-space: nowrap;
      min-width: 150px;
    }



    /* Login section styling */
    .x-btn {
      background: #1d9bf0;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      max-width: 300px;
      margin: 0 auto 20px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: background 0.2s;
    }

    .x-btn:hover {
      background: #1a8cd8;
    }

    .login-divider {
      color: #8b949e;
      margin: 20px 0;
      display: flex;
      align-items: center;
      text-transform: uppercase;
      font-size: 12px;
    }

    .login-divider::before,
    .login-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #30363d;
      margin: 0 10px;
    }

    #loginEmailForm {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 300px;
      margin: 0 auto;
    }

    #loginEmailForm input {
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #f0f6fc;
      font-size: 14px;
      width: 100%;
    }

    #loginEmailForm input:focus {
      border-color: #58a6ff;
      outline: none;
    }

    .login-actions {
      display: flex;
      gap: 8px;
    }

    .login-actions button {
      flex: 1;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #30363d;
      background: #21262d;
      color: #f0f6fc;
      cursor: pointer;
      font-size: 14px;
    }

    .login-actions button[type="submit"] {
      background: #238636;
      border-color: #238636;
    }

    .login-actions button:hover {
      background: #30363d;
    }

    .login-actions button[type="submit"]:hover {
      background: #2ea043;
    }

    #forgotPasswordLink {
      color: #58a6ff;
      text-decoration: none;
      font-size: 14px;
      text-align: center;
      margin-top: 8px;
    }

    #forgotPasswordLink:hover {
      text-decoration: underline;
    }

    /* Burger Menu Styles */
    .burger-menu {
      position: absolute;
      left: 20px;
      top: 20px;
      z-index: 1000;
    }

    .burger-icon {
      cursor: pointer;
      padding: 10px;
    }

    .burger-icon span {
      display: block;
      width: 25px;
      height: 3px;
      background-color: #f0f6fc;
      margin: 5px 0;
      transition: 0.3s;
    }

    .burger-icon.active span:nth-child(1) {
      transform: rotate(-45deg) translate(-5px, 6px);
    }

    .burger-icon.active span:nth-child(2) {
      opacity: 0;
    }

    .burger-icon.active span:nth-child(3) {
      transform: rotate(45deg) translate(-5px, -6px);
    }

    .menu-items {
      position: absolute;
      top: 100%;
      left: 0;
      background: #1a1d20;
      border-radius: 12px;
      padding: 16px;
      display: none;
      min-width: 250px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }

    .menu-items.active {
      display: block;
    }

    .menu-item {
      display: block;
      padding: 12px 16px;
      color: #f0f6fc;
      text-decoration: none;
      font-size: 18px;
      background: #2a2e33;
      border-radius: 8px;
      margin-bottom: 8px;
      border: none;
      width: 100%;
      text-align: center;
      cursor: pointer;
    }

    .menu-item:hover {
      background-color: #238636;
    }

    .menu-divider {
      height: 1px;
      background-color: #30363d;
      margin: 16px 0;
    }

    .menu-item.username {
      background: transparent;
      text-align: center;
      padding: 4px;
      margin-bottom: 16px;
    }

    .menu-item.sign-in {
      background: transparent;
      text-align: center;
      color: #8b949e;
    }

    .menu-item.logout-btn {
      background: #da3633;
      margin-top: 8px;
    }

    .menu-item.logout-btn:hover {
      background: #b91c1c;
    }

    /* Voting Stats Sections */
    .voting-stats {
      margin: 2rem 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      padding: 0 16px;
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      background: #161b22;
      border-radius: 8px;
      overflow: hidden;
    }

    .stats-table th,
    .stats-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #30363d;
    }

    .stats-table th {
      background: #1c2128;
      color: #8b949e;
      font-weight: 600;
    }

    .stats-table td {
      color: #f0f6fc;
    }

    /* Right-align numeric columns */
    .stats-table td:nth-child(2),
    .stats-table td:nth-child(3) {
      text-align: right;
    }

    .stats-table th:nth-child(2),
    .stats-table th:nth-child(3) {
      text-align: right;
    }

    @media (max-width: 768px) {
      .voting-stats {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 0 8px;
      }

      .friends-section,
      .foes-section {
        padding: 15px;
      }

      .stats-table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        margin: 0 -15px; /* Extend to full width */
        padding: 0 15px; /* Add back internal padding */
      }

      .stats-table {
        font-size: 12px;
        min-width: 280px; /* Minimum width to ensure readability */
        width: 100%;
      }

      .stats-table th,
      .stats-table td {
        padding: 6px 4px;
        white-space: nowrap; /* Prevent text wrapping */
      }

      /* Optimize column widths for mobile */
      .stats-table th:nth-child(1),
      .stats-table td:nth-child(1) {
        width: 50%;
        white-space: normal; /* Allow voter names to wrap if needed */
        word-break: break-word;
      }

      .stats-table th:nth-child(2),
      .stats-table td:nth-child(2) {
        width: 25%;
        text-align: center;
      }

      .stats-table th:nth-child(3),
      .stats-table td:nth-child(3) {
        width: 25%;
        text-align: center;
      }

      /* Ensure the no-data message fits well */
      .no-data-message {
        font-size: 12px;
        padding: 10px;
      }
    }

    /* Hide burger menu on larger screens */
    @media (min-width: 769px) {
      .burger-menu {
        display: none;
      }
    }

    /* Mobile notification button styling */
    .mobile-notification-btn {
      background: transparent;
      border: 1px solid #30363d;
      color: #f0f6fc;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      text-align: left;
      margin: 8px 0;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .mobile-notification-btn:hover {
      background: #21262d;
      border-color: #58a6ff;
    }

    .mobile-notification-count {
      background: #f85149;
      color: white;
      border-radius: 12px;
      padding: 2px 8px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
    }

    /* Hamburger button notification dot */
    .hamburger-notification-dot {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 12px;
      height: 12px;
      background: #f85149;
      border-radius: 50%;
      border: 2px solid #0d1117;
      z-index: 1101;
    }

    /* Initially hide main content until auth check completes */
    .layout,
    .header h1 {
      opacity: 0;
      visibility: hidden;
    }

    /* Show content when auth is confirmed */
    .content-visible .layout,
    .content-visible .header h1 {
      opacity: 1;
      visibility: visible;
      transition: opacity 0.2s ease;
    }

    /* Ensure proper flex layout for footer positioning */
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Make sure login required message takes up available space */
    .login-required {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Ensure main content area also takes up available space */
    .main-content-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    /* Footer should be at bottom */
    .legal-footer {
      margin-top: auto;
    }

    /* Rating boxes with tier-based colors */
    .rating-box {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 18px;
      min-width: 40px;
      text-align: center;
      border: 2px solid;
      margin-right: 16px;
    }

    .profile-name-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
    }

    @media (max-width: 768px) {
      .rating-box {
        padding: 6px 10px;
        font-size: 16px;
        min-width: 36px;
        margin-right: 12px;
      }
      
      .profile-name-container {
        flex-direction: row;
        align-items: center;
      }

      /* Keep consistent table rating box size on mobile */
      .vote-results-table .rating-box {
        padding: 3px 6px;
        font-size: 10px;
        min-width: 20px;
        margin: 0;
      }
    }

    /* Tier colors based on Madden rating ranges */
    .rating-box.tier-none {
      background-color: #374151;
      color: #9ca3af;
      border-color: #4b5563;
    }

    .rating-box.tier-low {
      background-color: #dc2626;
      color: #ffffff;
      border-color: #b91c1c;
    }

    .rating-box.tier-below {
      background-color: #ea580c;
      color: #ffffff;
      border-color: #c2410c;
    }

    .rating-box.tier-average {
      background-color: #ca8a04;
      color: #ffffff;
      border-color: #a16207;
    }

    .rating-box.tier-good {
      background-color: #16a34a;
      color: #ffffff;
      border-color: #15803d;
    }

    .rating-box.tier-elite {
      background-color: #2563eb;
      color: #ffffff;
      border-color: #1d4ed8;
    }

    .rating-box.tier-bottom {
      background-color: #991b1b;
      color: #ffffff;
      border-color: #7f1d1d;
    }

    .rating-box.tier-below-avg {
      background-color: #f97316;
      color: #ffffff;
      border-color: #ea580c;
    }

    .rating-box.tier-above-avg {
      background-color: #22c55e;
      color: #ffffff;
      border-color: #16a34a;
    }

    /* Tournament table specific column widths */
    #tournamentsContent .vote-results-table th:first-child,
    #tournamentsContent .vote-results-table td:first-child {
      width: 120px;
      min-width: 120px;
    }

    #tournamentsContent .vote-results-table th:nth-child(2),
    #tournamentsContent .vote-results-table td:nth-child(2) {
      width: 100px;
      min-width: 100px;
    }

    #tournamentsContent .vote-results-table th:nth-child(3),
    #tournamentsContent .vote-results-table td:nth-child(3) {
      width: auto;
      min-width: 0;
    }
  </style>
</head>
<body>
  <div class="main-content-wrapper">
    <div class="header" style="justify-content:center; margin-top: 20px;">
      <h1>Profile</h1>
    </div>

    <!-- Insert login required message for unauthenticated users -->
    <div id="loginRequiredMessage" class="login-required" style="display:none;">
      <h2>You need to be logged in to view this page</h2>
      <button id="goLoginBtn" class="start-voting-btn">Login →</button>
    </div>

    <div class="layout" style="flex-direction:column; align-items:center;">
    <div class="profile-header">
      <div id="profileInfo"></div>
    </div>

    <div class="achievements">
      <h2>Achievements</h2>
      <p class="coming-soon">Coming Soon!</p>
    </div>

    <div class="voting-stats">
      <div class="friends-section">
        <h2>Your Friends</h2>
        <p class="subtitle">These voters love your teams!</p>
        <div class="stats-table-container">
          <table class="stats-table">
            <thead>
              <tr>
                <th>Voter</th>
                <th>Win Rate</th>
                <th>Record</th>
              </tr>
            </thead>
            <tbody id="friends-tbody">
              <!-- Filled by JavaScript -->
            </tbody>
          </table>
          <p id="no-friends" class="no-data-message" style="display: none;">
            No voting data yet! Upload some teams and get people to vote on them.
          </p>
        </div>
      </div>

      <div class="foes-section">
        <h2>Your Foes</h2>
        <p class="subtitle">These voters might need convincing...</p>
        <div class="stats-table-container">
          <table class="stats-table">
            <thead>
              <tr>
                <th>Voter</th>
                <th>Win Rate</th>
                <th>Record</th>
              </tr>
            </thead>
            <tbody id="foes-tbody">
              <!-- Filled by JavaScript -->
            </tbody>
          </table>
          <p id="no-foes" class="no-data-message" style="display: none;">
            No foes yet!
          </p>
        </div>
      </div>
    </div>

    <!-- Tournaments, Uploads & Vote Results tabs -->
    <div class="uploads-section">
      <div class="tab-header">
        <button id="tabTournaments" class="tab-btn active">Tournaments</button>
        <button id="tabUploads" class="tab-btn">Uploads</button>
        <button id="tabResults" class="tab-btn">Vote Results</button>
      </div>
      <div id="tournamentsContent" class="tab-content"></div>
      <div id="uploadsSummary" class="tab-content" style="display:none;"></div>
      <div id="voteResultsContent" class="tab-content" style="display:none;"></div>
      <button id="mainLogoutBtn" class="logout-btn">Logout</button>
    </div>

  </div>
  </div>

  <script>
    function formatEloRatingBox(eloRating, percentile, isUserRating = false) {
      if (!eloRating || eloRating === 0) return '<span class="rating-box tier-none">-</span>';
      
      // Use percentile directly to determine color tier
      const tierClass = isUserRating ? getUserPercentileTierClass(percentile) : getTeamPercentileTierClass(percentile);
      
      return `<span class="rating-box ${tierClass}">${Math.round(eloRating)}</span>`;
    }

    // Helper to determine color tier from percentile for team ratings
    function getTeamPercentileTierClass(percentile) {
      if (percentile < 0.10) {
        return 'tier-bottom';   // 0-10%: Dark Red
      } else if (percentile < 0.30) {
        return 'tier-low';      // 10-30%: Red
      } else if (percentile < 0.50) {
        return 'tier-below';    // 30-50%: Orange
      } else if (percentile < 0.70) {
        return 'tier-average';  // 50-70%: Yellow
      } else if (percentile < 0.90) {
        return 'tier-good';     // 70-90%: Green
      } else {
        return 'tier-elite';    // 90-100%: Blue
      }
    }

    // Helper to determine color tier from percentile for user ratings (more generous tiers)
    function getUserPercentileTierClass(percentile) {
      if (percentile < 0.2) {
        return 'tier-bottom';   // 0-5%: Dark Red
      } else if (percentile < 0.4) {
        return 'tier-low';      // 5-20%: Red
      } else if (percentile < 0.6) {
        return 'tier-average';  // 40-60%: Yellow
      } else if (percentile < 0.8) {
        return 'tier-good';     // 60-85%: Green
      } else {
        return 'tier-elite';    // 85-100%: Blue
      }
    }

    // Legacy function for backward compatibility - defaults to team rating tiers
    function getPercentileTierClass(percentile) {
      return getTeamPercentileTierClass(percentile);
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Track whether we're viewing our own profile globally
      let viewingOwnProfile = false;
      // Check for URL parameters to determine which user to load
      const urlParams = new URLSearchParams(window.location.search);
      const viewingUsername = urlParams.get('user');
      
      // Helper to show login required message and hide the main content
      function showLoginRequired() {
        // Add content-visible class to show elements
        document.body.classList.add('content-visible');
        
        // Hide main content containers
        const layoutEl = document.querySelector('.layout');
        if (layoutEl) layoutEl.style.display = 'none';
        const headerTitle = document.querySelector('.header h1');
        if (headerTitle) headerTitle.style.display = 'none';

        // Show the login prompt
        const msgDiv = document.getElementById('loginRequiredMessage');
        if (msgDiv) msgDiv.style.display = 'block';

        // Bind click handler once
        const btn = document.getElementById('goLoginBtn');
        if (btn && !btn.dataset.bound) {
          btn.dataset.bound = '1';
          btn.addEventListener('click', () => {
            window.location.href = '/upload';
          });
        }
      }

      // Check auth status first, then load profile
      fetch('/me')
        .then(res => res.json())
        .then(data => {
          const loggedIn = !!data.user;
          if (loggedIn) {
            // User is logged in, proceed to load profile
            document.body.classList.add('content-visible');
            loadProfile();
          } else {
            // User is not logged in, show login required message
            showLoginRequired();
          }
        })
        .catch(err => {
          showLoginRequired();
        });

      // Load profile data
      function loadProfile() {
        let profileEndpoint;
        if (viewingUsername) {
          // Viewing someone else's profile
          profileEndpoint = `/profile/${encodeURIComponent(viewingUsername)}`;
        } else {
          // Viewing own profile
          profileEndpoint = '/my/profile';
        }

        fetch(profileEndpoint)
          .then(async res => {
            if (res.status === 401) {
              // Not logged in - show login required message
              showLoginRequired();
              return null;
            } else if (!res.ok) {
              throw new Error('Failed to load profile');
            }
            return res.json();
          })
          .then(data => {
            if (!data) return;

            const { user, uploads, voteResults, isOwnProfile, viewerLoggedIn } = data;
            const infoDiv = document.getElementById('profileInfo');
            const uploadsDiv = document.getElementById('uploadsSummary');

            // Persist
            viewingOwnProfile = isOwnProfile;

            // Set gear button active state based on whether viewing own profile
            const userGear = document.getElementById('userGear');
            if (userGear) {
              if (isOwnProfile) {
                userGear.classList.add('active');
              } else {
                userGear.classList.remove('active');
              }
            }

            // Profile header - show edit button only for own profile
            const editButton = isOwnProfile ? 
              `<button class="edit-display-name" onclick="editDisplayName('${user.display_name || ''}')">Edit</button>` : '';
            
            const displayName = user.display_name || (viewingUsername || 'User Profile Name Needed');
            const displayNameClass = !user.display_name && isOwnProfile ? 'class="no-display-name"' : '';
            window.profileUserName = (user.display_name || viewingUsername || '').toLowerCase();
                        
            // Add Elo rating if available (we'll need to get this from the API)
            const eloRatingDisplay = data.eloRating ? formatEloRatingBox(data.eloRating, data.percentile, true) : ''; // true indicates user rating
            
            infoDiv.innerHTML = `
              ${editButton}
              <h2>
                <div class="profile-name-container">
                  ${eloRatingDisplay}
                  <span id="displayNameContainer" ${displayNameClass}>
                    ${displayName}
                  </span>
                </div>
              </h2>
              ${user.twitter_username ? `<p>@${user.twitter_username}</p>` : ''}
            `;

            // Handle uploads section - only show for own profile
            if (isOwnProfile && uploads) {
              // Build uploads table
              let tableHtml = `
                <table class="uploads-table">
                  <thead>
                    <tr>
                      <th>Username</th>
                      <th>Tournament</th>
                      <th>Count</th>
                    </tr>
                  </thead>
                  <tbody>
              `;

              uploads.forEach(row => {
                tableHtml += `
                  <tr>
                    <td>${row.username}</td>
                    <td>${row.tournament}</td>
                    <td>${row.count}</td>
                  </tr>
                `;
              });

              tableHtml += '</tbody></table>';
              uploadsDiv.innerHTML = tableHtml;
            } else {
              uploadsDiv.innerHTML = '';
            }

            // --- Store and render Vote Results with sortable table ---
            window.voteResultsData = voteResults || [];
            window.voteSortKey = 'elo_rating';
            window.voteSortDir = 'desc';
            const resultsDiv = document.getElementById('voteResultsContent');

            function sortVoteData() {
              const key = window.voteSortKey;
              const dir = window.voteSortDir;
              const mul = dir === 'asc' ? 1 : -1;
              return [...window.voteResultsData].sort((a,b) => {
                if (key === 'win_pct') {
                  if (a.win_pct !== b.win_pct) return (b.win_pct - a.win_pct) * (dir === 'desc' ? 1 : -1);
                  // tie-breaker
                  if (dir === 'desc') {
                    return (b.wins - a.wins);
                  } else {
                    // For ascending Win %, break ties by losses descending (more losses = higher priority)
                    return (b.losses - a.losses);
                  }
                }
                if (key === 'wins') {
                  if (a.wins !== b.wins) return (b.wins - a.wins) * (dir === 'desc' ? 1 : -1);
                  return (b.win_pct - a.win_pct) * (dir === 'desc' ? 1 : -1);
                }
                if (key === 'losses') {
                  if (a.losses !== b.losses) return (b.losses - a.losses) * (dir === 'desc' ? 1 : -1);
                  return (b.win_pct - a.win_pct) * (dir === 'desc' ? 1 : -1);
                }
                if (key === 'tournament') {
                  const ta = (b.tournament || '').localeCompare(a.tournament || ''); // Reversed comparison for descending
                  return ta * (dir === 'desc' ? 1 : -1);
                }
                if (key === 'elo_rating') {
                  const ae = parseFloat(a.elo_rating || 0);
                  const be = parseFloat(b.elo_rating || 0);
                  if (ae !== be) return (be - ae) * (dir === 'desc' ? 1 : -1);
                  return (b.win_pct - a.win_pct) * (dir === 'desc' ? 1 : -1);
                }
                return 0;
              });
            }

            function renderVoteResultsTable() {
              if (!window.voteResultsData.length) {
                resultsDiv.innerHTML = '<p style="text-align:center; padding:20px; color:#8b949e;">No vote data yet. Once people start voting on your teams, results will appear here!</p>';
                return;
              }

              const sorted = sortVoteData();
              let html = `
                <table class="uploads-table vote-results-table">
                  <thead>
                    <tr>
                      <th>Team</th>
                      <th class="sortable" data-key="elo_rating">Draftr Rating</th>
                      <th class="sortable" data-key="tournament">Contest</th>
                      <th class="sortable" data-key="wins">W</th>
                      <th class="sortable" data-key="losses">L</th>
                      <th class="sortable" data-key="win_pct">Win %</th>
                    </tr>
                  </thead>
                  <tbody>
              `;

              sorted.forEach(r => {
                const winPct = parseFloat(r.win_pct) === 0 ? '0' : r.win_pct;
                const eloRatingDisplay = r.elo_rating ? formatEloRatingBox(r.elo_rating, r.percentile) : '<span class="rating-box tier-none">-</span>';
                html += `
                  <tr>
                    <td>
                      <button class="view-team-btn" data-id="${r.id}">View Team</button>
                      <button class="view-votes-btn" data-id="${r.id}">View Votes</button>
                    </td>
                    <td>${eloRatingDisplay}</td>
                    <td>${r.tournament || '-'}</td>
                    <td>${r.wins}</td>
                    <td>${r.losses}</td>
                    <td>${winPct}%</td>
                  </tr>
                `;
              });

              html += '</tbody></table>';
              resultsDiv.innerHTML = html;

              // Attach header click listeners
              resultsDiv.querySelectorAll('th.sortable').forEach(th => {
                th.onclick = () => {
                  const key = th.getAttribute('data-key');
                  if (window.voteSortKey === key) {
                    window.voteSortDir = window.voteSortDir === 'desc' ? 'asc' : 'desc';
                  } else {
                    window.voteSortKey = key;
                    window.voteSortDir = 'desc';
                  }
                  renderVoteResultsTable();
                };
              });

              // Attach view button listeners to show popup
              resultsDiv.querySelectorAll('.view-team-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                  const id = e.target.getAttribute('data-id');
                  if (!id || typeof showSimplePopup !== 'function') return;
                  try {
                    const res = await fetch(`/team/${id}`);
                    if (!res.ok) throw new Error('Failed');
                    const players = await res.json();
                    const card = buildTeamCard(id, players);
                    const list = card.querySelector('.player-list');
                    if (list) showSimplePopup(list.cloneNode(true));
                  } catch (err) {
                    console.error('Failed to load team:', err);
                  }
                });
              });

              // Attach view votes button listeners
              resultsDiv.querySelectorAll('.view-votes-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                  const id = e.target.getAttribute('data-id');
                  window.location.href = `voting-history.html?teamId=${id}`;
                });
              });
            }

            renderVoteResultsTable();

            // ---- Load Tournament Teams ----
            if (isOwnProfile) {
              loadTournamentTeams();
            }

            // Store usernames globally for the edit function (only for own profile)
            if (isOwnProfile && data.usernames) {
              window.availableUsernames = data.usernames;
            }

            // ---- Populate Friends & Foes ----
            if (data.votingStats && (data.votingStats.friends.length || data.votingStats.foes.length)) {
              populateVotingStats(data.votingStats);
            } else {
              document.querySelector('.voting-stats').style.display = 'none';
            }

            // ---- Update tab visibility based on viewing mode ----
            const tabUploadsBtn = document.getElementById('tabUploads');
            const tabResultsBtn = document.getElementById('tabResults');
            const uploadsContent = document.getElementById('uploadsSummary');
            const resultsContent = document.getElementById('voteResultsContent');
            const mainLogoutBtn = document.getElementById('mainLogoutBtn');

            if (isOwnProfile) {
              // Own profile: show all tabs, default to tournaments
              tabTournamentsBtn.style.display = '';
              tabUploadsBtn.style.display = '';
              tabResultsBtn.style.display = '';
              if (mainLogoutBtn) mainLogoutBtn.style.display = '';
              setActive('tournaments');
            } else {
              // Other profile: hide tournaments and uploads tabs, show only vote results, hide logout
              tabTournamentsBtn.style.display = 'none';
              tabUploadsBtn.style.display = 'none';
              tabResultsBtn.style.display = 'none'; // Hide tab header entirely
              tournamentsContent.style.display = 'none';
              uploadsContent.style.display = 'none';
              resultsContent.style.display = '';
              if (mainLogoutBtn) mainLogoutBtn.style.display = 'none';
              // Update tab header to just show "Vote Results" as title
              document.querySelector('.tab-header').innerHTML = '<h3 style="margin:0;">Vote Results</h3>';
            }
          })
          .catch(err => {
            console.error('Failed to load profile:', err);
            alert('Failed to load profile information.');
          });
      }

      // Load nominations data and deadline status, then cache them
      async function loadNominationsData() {
        const tournament = 'The Puppy';
        
        try {
          // Check deadline status and load nominations in parallel
          const [nominationsRes, deadlineRes] = await Promise.all([
            fetch('/my/nominations?tournament=' + encodeURIComponent(tournament)),
            fetch('/tournament/deadline-status')
          ]);
          
          if (!nominationsRes.ok) {
            console.error('Failed to load nominations');
            return;
          }
          
          const nominationsData = await nominationsRes.json();
          const nominations = nominationsData.nominations || [];
          window.nominatedTeamIds = new Set(nominations.map(n => n.id));
          
          // Handle deadline status
          if (deadlineRes.ok) {
            const deadlineData = await deadlineRes.json();
            window.nominationsDeadlinePassed = deadlineData.hasDeadlinePassed;
            console.log('Nominations deadline passed:', window.nominationsDeadlinePassed);
          } else {
            window.nominationsDeadlinePassed = false; // fallback to allow nominations
          }
          
        } catch (err) {
          console.error('Failed to load nominations:', err);
          window.nominatedTeamIds = new Set(); // fallback to empty set
          window.nominationsDeadlinePassed = false; // fallback to allow nominations
        }
      }

      // Update button states based on cached nominations
      function updateButtonStates() {
        const nominatedTeamIds = window.nominatedTeamIds || new Set();
        const deadlinePassed = window.nominationsDeadlinePassed || false;
        
        // Update button states based on nominations
        document.querySelectorAll('.select-team-btn').forEach(btn => {
          const teamId = btn.getAttribute('data-id');
          
          if (deadlinePassed) {
            // Deadline passed - disable all nomination buttons
            btn.disabled = true;
            btn.classList.add('disabled');
            if (nominatedTeamIds.has(teamId)) {
              btn.textContent = 'Nominated';
              btn.classList.add('nominated');
            } else {
              btn.textContent = 'Closed';
              btn.classList.remove('nominated');
            }
          } else {
            // Deadline not passed - normal functionality
            btn.disabled = false;
            btn.classList.remove('disabled');
            if (nominatedTeamIds.has(teamId)) {
              btn.classList.add('nominated');
              btn.textContent = 'Nominated';
            } else {
              btn.classList.remove('nominated');
              btn.textContent = 'Select';
            }
          }
        });
      }

      // Add event listeners for nomination buttons
      function attachNominationListeners() {
        const tournament = 'The Puppy';
        
        document.querySelectorAll('.select-team-btn').forEach(btn => {
          // Remove any existing listeners by cloning the element
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
          
          // Add event listener for nomination toggle
          newBtn.addEventListener('click', async (e) => {
            const clickedTeamId = e.target.getAttribute('data-id');
            
            if (!clickedTeamId) return;
            
            // Check if deadline has passed
            const deadlinePassed = window.nominationsDeadlinePassed || false;
            if (deadlinePassed) {
              showSimplePopup('Tournament nominations are now closed. The deadline has passed.');
              return;
            }
            
            // Check if button is disabled
            if (e.target.disabled || e.target.classList.contains('disabled')) {
              return;
            }
            
            try {
              const isNominated = e.target.classList.contains('nominated');
              const endpoint = isNominated ? '/my/unnominate-team' : '/my/nominate-team';
              
              const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  teamId: clickedTeamId,
                  tournament: tournament
                })
              });
              
              const result = await response.json();
              
              if (response.ok) {
                // Update cached data
                if (isNominated) {
                  window.nominatedTeamIds.delete(clickedTeamId);
                  e.target.classList.remove('nominated');
                  e.target.textContent = 'Select';
                } else {
                  window.nominatedTeamIds.add(clickedTeamId);
                  e.target.classList.add('nominated');
                  e.target.textContent = 'Nominated';
                }
              } else {
                // Show error message
                showSimplePopup(`${result.error || 'Failed to update nomination'}`);
              }
            } catch (err) {
              console.error('Failed to update nomination:', err);
              showSimplePopup('Failed to update nomination. Please try again.');
            }
          });
        });
      }

      // Load tournament teams for The Puppy tournament
      async function loadTournamentTeams() {
        const tournamentsDiv = document.getElementById('tournamentsContent');
        if (!tournamentsDiv) return;

        tournamentsDiv.innerHTML = '<div style="text-align:center; padding:20px; color:#8b949e;">Loading tournament teams...</div>';

        try {
          const res = await fetch('/my/tournament-teams?tournament=' + encodeURIComponent('The Puppy'));
          if (!res.ok) {
            throw new Error('Failed to load tournament teams');
          }

          const data = await res.json();
          const teams = data.teams || [];

          if (teams.length === 0) {
            tournamentsDiv.innerHTML = '<div style="text-align:center; padding:20px; color:#8b949e;">No teams found for The Puppy tournament. Upload some teams to get started!</div>';
            return;
          }

          // Store teams data and sorting state
          window.tournamentTeamsData = teams;
          window.tournamentSortKey = 'elo_rating';
          window.tournamentSortDir = 'desc';
          
          // Load nominations once and cache them
          await loadNominationsData();

          // Show deadline message if nominations are closed
          if (window.nominationsDeadlinePassed) {
            const deadlineMessage = document.createElement('div');
            deadlineMessage.className = 'deadline-message';
            deadlineMessage.style.cssText = `
              background: rgba(218, 54, 51, 0.1);
              border: 1px solid rgba(248, 81, 73, 0.3);
              border-radius: 8px;
              padding: 1rem;
              margin-bottom: 1rem;
              text-align: center;
              color: #f85149;
              font-weight: 600;
            `;
            deadlineMessage.innerHTML = '⏰ Tournament nominations are now closed. The deadline has passed.';
            tournamentsDiv.insertBefore(deadlineMessage, tournamentsDiv.firstChild);
          }

          function sortTournamentData() {
            const key = window.tournamentSortKey;
            const dir = window.tournamentSortDir;
            const mul = dir === 'asc' ? 1 : -1;
            return [...window.tournamentTeamsData].sort((a,b) => {
              if (key === 'elo_rating') {
                const ae = parseFloat(a.elo_rating || 0);
                const be = parseFloat(b.elo_rating || 0);
                if (ae !== be) return (be - ae) * (dir === 'desc' ? 1 : -1);
                return 0;
              }
              if (key === 'tournament') {
                const ta = (b.tournament || '').localeCompare(a.tournament || '');
                return ta * (dir === 'desc' ? 1 : -1);
              }
              return 0;
            });
          }

          async function renderTournamentTable() {
            const sorted = sortTournamentData();
            let tableHtml = `
              <table class="uploads-table vote-results-table">
                <thead>
                  <tr>
                    <th>Team</th>
                    <th class="sortable" data-key="elo_rating">Draftr Rating</th>
                    <th class="sortable" data-key="tournament">Contest</th>
                  </tr>
                </thead>
                <tbody>
            `;

            sorted.forEach(team => {
              const eloRatingDisplay = team.elo_rating ? formatEloRatingBox(team.elo_rating, team.percentile) : '<span class="rating-box tier-none">-</span>';
              
              tableHtml += `
                <tr>
                  <td>
                    <button class="view-team-btn" data-id="${team.id}">View Team</button>
                    <button class="select-team-btn" data-id="${team.id}">Select</button>
                  </td>
                  <td>${eloRatingDisplay}</td>
                  <td>${team.tournament || '-'}</td>
                </tr>
              `;
            });

            tableHtml += '</tbody></table>';
            tournamentsDiv.innerHTML = tableHtml;

                        // Attach header click listeners for sorting
            tournamentsDiv.querySelectorAll('th.sortable').forEach(th => {
              th.onclick = () => {
                const key = th.getAttribute('data-key');
                if (window.tournamentSortKey === key) {
                  window.tournamentSortDir = window.tournamentSortDir === 'desc' ? 'asc' : 'desc';
                } else {
                  window.tournamentSortKey = key;
                  window.tournamentSortDir = 'desc';
                }
                renderTournamentTable();
              };
            });

            // Attach view team button listeners
            tournamentsDiv.querySelectorAll('.view-team-btn').forEach(btn => {
              btn.addEventListener('click', async (e) => {
                const id = e.target.getAttribute('data-id');
                if (!id || typeof showSimplePopup !== 'function') return;
                try {
                  const res = await fetch(`/team/${id}`);
                  if (!res.ok) throw new Error('Failed');
                  const players = await res.json();
                  const card = buildTeamCard(id, players);
                  const list = card.querySelector('.player-list');
                  if (list) showSimplePopup(list.cloneNode(true));
                } catch (err) {
                  console.error('Failed to load team:', err);
                }
              });
            });

            // Update button states and attach listeners (no API call)
            updateButtonStates();
            attachNominationListeners();
          }

          // Initial render of the table
          await renderTournamentTable();

        } catch (err) {
          console.error('Failed to load tournament teams:', err);
          tournamentsDiv.innerHTML = '<div style="text-align:center; padding:20px; color:#f85149;">Failed to load tournament teams. Please try again.</div>';
        }
      }

      // Ensure gear button highlights correctly once header is injected
      document.addEventListener('headerLoaded', () => {
        try {
          if (window.viewingOwnProfile) {
            const gear = document.getElementById('userGear');
            if (gear) {
              gear.classList.add('active');
            }
          }
        } catch (err) {
          console.error('Failed to set gear active state after header load', err);
        }
      });

      // Helper to render voting stats
      function populateVotingStats(stats) {
        const friendsTbody = document.getElementById('friends-tbody');
        const foesTbody = document.getElementById('foes-tbody');
        const noFriendsMsg = document.getElementById('no-friends');
        const noFoesMsg = document.getElementById('no-foes');

        function escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        function createRow(v) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${escapeHtml(v.name)}</td>
            <td>${v.winRate}%</td>
            <td>${v.wins}-${v.losses}</td>
          `;
          return tr;
        }

        friendsTbody.innerHTML = '';
        foesTbody.innerHTML = '';

        friendsTbody.parentElement.parentElement.style.display = 'block'; // ensure visible
        foesTbody.parentElement.parentElement.style.display = 'block';

        // Exclude the profile owner from friends & foes lists
        const profileName = (window.profileUserName || '').toLowerCase();
        const filteredFriends = stats.friends.filter(v => (v.name || '').toLowerCase() !== profileName);
        const filteredFoes = stats.foes.filter(v => (v.name || '').toLowerCase() !== profileName);

        noFriendsMsg.style.display = filteredFriends.length ? 'none' : 'block';
        noFoesMsg.style.display = filteredFoes.length ? 'none' : 'block';

        filteredFriends.forEach(f => friendsTbody.appendChild(createRow(f)));
        filteredFoes.forEach(f => foesTbody.appendChild(createRow(f)));
      }

      // Logout functionality handled below in header navigation setup

      // === Tab switching logic ===
      const tabTournamentsBtn = document.getElementById('tabTournaments');
      const tabUploadsBtn = document.getElementById('tabUploads');
      const tabResultsBtn = document.getElementById('tabResults');
      const tournamentsContent = document.getElementById('tournamentsContent');
      const uploadsContent = document.getElementById('uploadsSummary');
      const resultsContent = document.getElementById('voteResultsContent');

      function setActive(tab) {
        // Remove active class from all buttons
        tabTournamentsBtn.classList.remove('active');
        tabUploadsBtn.classList.remove('active');
        tabResultsBtn.classList.remove('active');
        
        // Hide all content
        tournamentsContent.style.display = 'none';
        uploadsContent.style.display = 'none';
        resultsContent.style.display = 'none';
        
        // Show selected tab
        if (tab === 'tournaments') {
          tabTournamentsBtn.classList.add('active');
          tournamentsContent.style.display = '';
        } else if (tab === 'uploads') {
          tabUploadsBtn.classList.add('active');
          uploadsContent.style.display = '';
        } else if (tab === 'results') {
          tabResultsBtn.classList.add('active');
          resultsContent.style.display = '';
        }
      }

      tabTournamentsBtn.addEventListener('click', () => setActive('tournaments'));
      tabUploadsBtn.addEventListener('click', () => setActive('uploads'));
      tabResultsBtn.addEventListener('click', () => setActive('results'));


    });

    // Username editing functionality removed – usernames are updated via display name now

    // Display name editing functionality
    function editDisplayName(currentDisplayName) {
      const container = document.getElementById('displayNameContainer');
      const originalContent = container.innerHTML;
      const wasEmpty = !currentDisplayName;

      // Create edit interface
      container.innerHTML = `
        <input type="text" class="display-name-input" value="${currentDisplayName}" placeholder="Enter username">
        <button class="save-display-name">Save</button>
        <button class="cancel-display-name">Cancel</button>
        <div class="display-name-error" style="display:none; color:#f85149; margin-top:8px; font-size:14px;"></div>
      `;

      const input = container.querySelector('.display-name-input');
      const saveBtn = container.querySelector('.save-display-name');
      const cancelBtn = container.querySelector('.cancel-display-name');
      const errorDiv = container.querySelector('.display-name-error');

      // Hide error when user types again
      input.addEventListener('input', () => {
        errorDiv.style.display = 'none';
      });

      input.focus();
      input.select();

      // Handle save
      saveBtn.addEventListener('click', async () => {
        const newDisplayName = input.value.trim();
        
        try {
          const res = await fetch('/my/update-display-name', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ displayName: newDisplayName })
          });

          const data = await res.json();
          if (res.ok) {
            // Update the display without refreshing
            container.innerHTML = newDisplayName || 'Create Username';
            // Set styling class based on whether we have a display name
            if (newDisplayName) {
              container.classList.remove('no-display-name');
            } else {
              container.classList.add('no-display-name');
            }
          } else {
            errorDiv.textContent = data.error || 'Username already taken.';
            errorDiv.style.display = 'block';
          }
        } catch (err) {
          console.error('Username already taken.', err);
          errorDiv.textContent = 'Username already taken.';
          errorDiv.style.display = 'block';
        }
      });

      // Handle cancel
      cancelBtn.addEventListener('click', () => {
        container.innerHTML = originalContent;
        if (wasEmpty) container.classList.add('no-display-name');
      });

      // Handle Enter key
      input.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') saveBtn.click();
        else if (e.key === 'Escape') cancelBtn.click();
      });
    }

    // Header navigation functionality
    document.addEventListener('DOMContentLoaded', () => {
      const mobileMenuToggle = document.getElementById('mobileMenuToggle');
      const mobileNav = document.getElementById('mobileNav');
      const userGear = document.getElementById('userGear');
      const notificationBell = document.getElementById('notificationBell');
      const notificationDropdown = document.getElementById('notificationDropdown');
      
      // Mobile menu toggle
      if (mobileMenuToggle && mobileNav) {
        mobileMenuToggle.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const isCurrentlyActive = mobileNav.classList.contains('active');
          
          if (isCurrentlyActive) {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          } else {
            mobileNav.classList.add('active');
            mobileMenuToggle.classList.add('active');
          }
        });

        // Close mobile menu when clicking on a link
        document.querySelectorAll('.mobile-nav-link').forEach(link => {
          link.addEventListener('click', () => {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          });
        });
        
        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!mobileMenuToggle.contains(e.target) && !mobileNav.contains(e.target)) {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          }
        });
      }

      // If header JS injected before our listener added, we may have missed headerLoaded.
      // Ensure mobile menu listeners are in place.
      if (!mobileMenuToggle || !mobileNav) {
        document.addEventListener('headerLoaded', () => {
          const tgl = document.getElementById('mobileMenuToggle');
          const navEl = document.getElementById('mobileNav');
          if (tgl && navEl) {
            tgl.addEventListener('click', (e)=>{
              e.preventDefault();e.stopPropagation();
              navEl.classList.toggle('active');
              tgl.classList.toggle('active');
            });
          }
        }, { once: true });
      }

      // User gear button - navigate to own profile
      if (userGear) {
        userGear.addEventListener('click', (e) => {
          e.stopPropagation();
          // Navigate to current user's profile (own profile)
          window.location.href = '/profile.html';
        });
      }

      // Notification dropdown toggle (load notifications on open)
      if (notificationBell && notificationDropdown) {
        notificationBell.addEventListener('click', (e) => {
          e.stopPropagation();
          const isVisible = notificationDropdown.style.display !== 'none';
          notificationDropdown.style.display = isVisible ? 'none' : 'block';
          if (!isVisible) {
            if (typeof loadDesktopNotifications === 'function') {
              loadDesktopNotifications();
            }
          }
        });
      }

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.user-controls')) {
          if (notificationDropdown) notificationDropdown.style.display = 'none';
        }
      });

      // Check auth status and update header UI
      fetch('/me')
        .then(res => res.json())
        .then(data => {
          const isAuthed = !!data.user;
          const displayName = isAuthed ? (data.user.display_name || data.user.email || 'User') : null;

          if (isAuthed && displayName) {
            // Add authenticated class to body for smooth CSS transitions
            document.body.classList.add('authenticated');
            
            // Update desktop user controls
            const userLabel = document.getElementById('userLabel');
            const mobileUserLabel = document.getElementById('mobileUserLabel');
            
            if (userLabel) userLabel.textContent = displayName;
            if (mobileUserLabel) mobileUserLabel.textContent = displayName;
            
            // Setup mobile notifications for authenticated users
            setupMobileNotifications();
          } else {
            // Remove authenticated class for CSS transitions
            document.body.classList.remove('authenticated');
          }
        })
        .catch(err => {
          console.error('Auth status check failed:', err);
        });

      // Logout functionality
      const logoutBtn = document.getElementById('logoutBtn'); // Header dropdown logout
      const mainLogoutBtn = document.getElementById('mainLogoutBtn'); // Main profile logout
      const mobileLogoutBtn = document.getElementById('mobileLogoutBtn');
      
      // Logout function to avoid repetition
      const handleLogout = async () => {
        try {
          await fetch('/logout', { method: 'POST' });
          window.location.href = '/';
        } catch (error) {
          console.error('Logout failed:', error);
          // Still redirect even if logout request fails
          window.location.href = '/';
        }
      };
      
      if (logoutBtn) {
        logoutBtn.addEventListener('click', handleLogout);
      }
      
      if (mainLogoutBtn) {
        mainLogoutBtn.addEventListener('click', handleLogout);
      }
      
      if (mobileLogoutBtn) {
        mobileLogoutBtn.addEventListener('click', handleLogout);
      }
    });

    // ---- Mobile Notification Functions ----
    
    let lastNotificationCount = 0;
    let notificationPollingInterval = null;

    function setupMobileNotifications() {
      // Update notification count and badge
      updateNotificationCount();
      
      // Setup mobile notification button click handler
      const mobileNotificationBtn = document.getElementById('mobileNotificationBtn');
      if (mobileNotificationBtn) {
        mobileNotificationBtn.style.display = 'block';
        mobileNotificationBtn.addEventListener('click', () => {
          showMobileNotifications();
        });
      }
      
      // Start notification polling
      startNotificationPolling();
    }

    // Attach mobile notifications setup immediately or on headerLoaded
    if (document.querySelector('.main-header')) {
      setupMobileNotifications();
    } else {
      document.addEventListener('headerLoaded', () => {
        setupMobileNotifications();
      }, { once: true });
    }

    async function updateNotificationCount() {
      try {
        const res = await fetch('/notifications/count');
        if (res.ok) {
          const data = await res.json();
          const count = data.count || 0;
          lastNotificationCount = count;
          updateNotificationBadge(count);
        } else {
          console.error('Failed to fetch notification count:', res.status, res.statusText);
        }
      } catch (e) {
        console.error('Failed to fetch notification count:', e);
      }
    }

    function updateNotificationBadge(count) {
      // Desktop badge
      const desktopBadge = document.getElementById('notificationBadge');
      if (desktopBadge) {
        if (count > 0) {
          desktopBadge.textContent = count > 99 ? '99+' : count;
          desktopBadge.style.display = 'inline';
        } else {
          desktopBadge.style.display = 'none';
        }
      }

      // Mobile badge
      const mobileBadge = document.getElementById('mobileNotificationBadge');
      if (mobileBadge) {
        if (count > 0) {
          mobileBadge.textContent = count > 99 ? '99+' : count;
          mobileBadge.style.display = 'inline';
        } else {
          mobileBadge.style.display = 'none';
        }
      }

      // Hamburger dot
      const burgerIcon = document.querySelector('.burger-icon');
      if (burgerIcon) {
        let dot = burgerIcon.querySelector('.hamburger-notification-dot');
        if (count > 0) {
          if (!dot) {
            dot = document.createElement('div');
            dot.className = 'hamburger-notification-dot';
            burgerIcon.appendChild(dot);
          }
        } else if (dot) {
          dot.remove();
        }
      }
    }

    function showMobileNotifications() {
      // Create mobile notification overlay if it doesn't exist
      let overlay = document.getElementById('mobileNotificationOverlay');
      if (!overlay) {
        overlay = createMobileNotificationOverlay();
        document.body.appendChild(overlay);
      }
      
      // Show the overlay
      overlay.style.display = 'flex';
      
      // Load notifications
      loadMobileNotifications();
    }

    function hideMobileNotifications() {
      const overlay = document.getElementById('mobileNotificationOverlay');
      if (overlay) {
        overlay.style.display = 'none';
      }
    }

    function createMobileNotificationOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'mobileNotificationOverlay';
      overlay.className = 'mobile-notification-overlay';
      
      overlay.innerHTML = `
        <div class="mobile-notification-content">
          <div class="mobile-notification-header">
            <h3>Notifications</h3>
            <div class="mobile-notification-actions">
              <button id="mobileMarkAllRead" class="mobile-mark-all-read-btn">Mark all read</button>
              <button id="closeMobileNotifications" class="mobile-close-notifications-btn">✖</button>
            </div>
          </div>
          <div id="mobileNotificationList" class="mobile-notification-list">
            <div class="loading">Loading notifications...</div>
          </div>
        </div>
      `;

      // Add event listeners
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          hideMobileNotifications();
        }
      });

      overlay.querySelector('#closeMobileNotifications').addEventListener('click', hideMobileNotifications);
      overlay.querySelector('#mobileMarkAllRead').addEventListener('click', markAllNotificationsAsReadMobile);
      
      return overlay;
    }

    async function loadMobileNotifications() {
      const notificationList = document.getElementById('mobileNotificationList');
      if (!notificationList) {
        console.error('Mobile notification list element not found');
        return;
      }

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        
        if (!res.ok) {
          console.error(`Notifications API error: ${res.status} ${res.statusText}`);
          if (res.status === 401) {
            notificationList.innerHTML = '<div class="no-notifications">Please log in to view notifications</div>';
          } else {
            notificationList.innerHTML = `<div class="no-notifications">Failed to load notifications (${res.status})</div>`;
          }
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];
        
        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = '';
        notifications.forEach((notification, index) => {
          try {
            const item = createMobileNotificationItem(notification);
            notificationList.appendChild(item);
          } catch (itemError) {
            console.error(`Error creating mobile notification item ${index}:`, itemError);
          }
        });
      } catch (e) {
        console.error('Failed to load mobile notifications:', e);
        notificationList.innerHTML = `<div class="no-notifications">Network error: ${e.message}</div>`;
      }
    }

    function createMobileNotificationItem(notification) {
      const item = document.createElement('div');
      item.className = `mobile-notification-item ${notification.is_read ? '' : 'unread'}`;
      item.dataset.notificationId = notification.id;

      const timeAgo = formatTimeAgo(new Date(notification.created_at));
      
      // Create enhanced notification message with links for versus votes
      let messageHTML = notification.message;
      
      if (notification.type === 'versus_vote' && notification.related_team_id) {
        // First, create the team link
        const teamLink = `<a href="voting-history.html?teamId=${notification.related_team_id}" style="color: #58a6ff; text-decoration: none;">your team</a>`;
        messageHTML = messageHTML.replace('your team', teamLink);
        
        // If we have opponent info, find and replace just the opponent name at the very end
        if (notification.opponent_team_id) {
          const againstIndex = messageHTML.lastIndexOf('against ');
          if (againstIndex !== -1) {
            const beforeAgainst = messageHTML.substring(0, againstIndex + 8);
            const opponentName = messageHTML.substring(againstIndex + 8);
            
            if (opponentName.trim()) {
              const opponentLink = `<span class="mobile-opponent-link" data-team-id="${notification.opponent_team_id}" style="color: #58a6ff; cursor: pointer; text-decoration: underline;">${opponentName}</span>`;
              messageHTML = beforeAgainst + opponentLink;
            }
          }
        }
      }
      
      item.innerHTML = `
        <div class="mobile-notification-message">${messageHTML}</div>
        <div class="mobile-notification-time">${timeAgo}</div>
      `;

      // Add click handlers for opponent links
      const opponentLinks = item.querySelectorAll('.mobile-opponent-link');
      opponentLinks.forEach(link => {
        link.addEventListener('click', async (e) => {
          e.stopPropagation();
          const teamId = link.getAttribute('data-team-id');
          if (teamId) {
            try {
              // Navigate to profile page for this opponent
              const meta = await fetchTeamMeta(teamId);
              if (meta && meta.username) {
                window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
              } else {
                // Fallback: navigate to voting history page
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            } catch (error) {
              console.error('Failed to navigate to opponent:', error);
              // Fallback: navigate to voting history page
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          }
        });
      });

      // Mark as read when clicked (but not when clicking links)
      item.addEventListener('click', async (e) => {
        if (e.target.tagName === 'A' || e.target.classList.contains('mobile-opponent-link')) {
          return;
        }
        
        if (!notification.is_read) {
          await markNotificationAsRead(notification.id);
          item.classList.remove('unread');
          await updateNotificationCount();
        }
      });

      return item;
    }

    async function markNotificationAsRead(notificationId) {
      try {
        await fetch('/notifications/read', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ notificationIds: [notificationId] })
        });
      } catch (e) {
        console.error('Failed to mark notification as read:', e);
      }
    }

    async function markAllNotificationsAsReadMobile() {
      try {
        const res = await fetch('/notifications/read-all', {
          method: 'POST'
        });
                if (res.ok) {
          // Immediately update the badge to 0 for instant feedback
          updateNotificationBadge(0);
          
          // Reload the notification list
          await loadMobileNotifications();
          
          // Wait a moment for database to update, then refresh count
          setTimeout(async () => {
            await updateNotificationCount();
          }, 500);
        } else {
          console.error('Failed to mark all notifications as read:', res.status, res.statusText);
        }
      } catch (e) {
        console.error('Failed to mark all notifications as read:', e);
      }
    }

    function formatTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);

      if (minutes < 1) return 'Just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;
      return date.toLocaleDateString();
    }

    async function fetchTeamMeta(teamId) {
      try {
        const response = await fetch(`/team-meta/${teamId}`);
        const data = await response.json();
        return data;
      } catch (error) {
        console.warn(`Failed to fetch team-meta for ${teamId}:`, error);
        return { username: null };
      }
    }

    function startNotificationPolling() {
      if (notificationPollingInterval) {
        clearInterval(notificationPollingInterval);
      }

      // Poll every 30 seconds
      notificationPollingInterval = setInterval(async () => {
        await updateNotificationCount();
      }, 30000);
    }

    function stopNotificationPolling() {
      if (notificationPollingInterval) {
        clearInterval(notificationPollingInterval);
        notificationPollingInterval = null;
      }
    }

    // ---- Desktop Notifications (dropdown) ----

    async function loadDesktopNotifications() {
      const notificationList = document.getElementById('notificationList');
      if (!notificationList) return;

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        if (!res.ok) {
          notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];

        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = notifications.map(notification => {
          const timeAgo = formatTimeAgo(new Date(notification.created_at));
          let msgHtml = notification.message;
          
          // Enhance versus_vote messages with links
          if (notification.type === 'versus_vote' && notification.related_team_id) {
            msgHtml = msgHtml.replace('your team', `<a href="voting-history.html?teamId=${notification.related_team_id}" style="color:#58a6ff;text-decoration:none;">your team</a>`);
            
            if (notification.opponent_team_id) {
              const againstIndex = msgHtml.lastIndexOf('against ');
              if (againstIndex !== -1) {
                const beforeAgainst = msgHtml.substring(0, againstIndex + 8);
                const opponentName = msgHtml.substring(againstIndex + 8);
                if (opponentName.trim()) {
                  msgHtml = beforeAgainst + `<span class="desktop-opponent-link" data-team-id="${notification.opponent_team_id}" style="color:#58a6ff;cursor:pointer;text-decoration:none;">${opponentName}</span>`;
                }
              }
            }
          }
          
          return `
            <div class="notification-item ${notification.is_read ? 'read' : 'unread'}" data-notification-id="${notification.id}">
              <div class="notification-message">${msgHtml}</div>
              <div class="notification-time">${timeAgo}</div>
            </div>
          `;
        }).join('');

        // Attach opponent link handlers
        document.querySelectorAll('.desktop-opponent-link').forEach(link => {
          link.addEventListener('click', async (e) => {
            e.stopPropagation();
            const teamId = link.getAttribute('data-team-id');
            if (!teamId) return;
            try {
              const res = await fetch(`/team-meta/${teamId}`);
              const meta = await res.json();
              if (meta && meta.username) {
                window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
              } else {
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            } catch (err) {
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          });
        });

        // Mark notifications as read when clicked
        document.querySelectorAll('.notification-item.unread').forEach(item => {
          item.addEventListener('click', async () => {
            const notificationId = item.dataset.notificationId;
            if (notificationId) {
              try {
                await fetch('/notifications/read', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ notificationIds: [parseInt(notificationId)] })
                });
                item.classList.remove('unread');
                item.classList.add('read');
                await updateNotificationCount();
              } catch (e) {
                console.error('Failed to mark notification as read:', e);
              }
            }
          });
        });

      } catch (e) {
        console.error('Failed to load desktop notifications:', e);
        notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
      }
    }

    async function markAllNotificationsAsRead() {
      try {
        const res = await fetch('/notifications/read-all', { method: 'POST' });
        if (res.ok) {
          updateNotificationBadge(0);
          await loadDesktopNotifications();
          setTimeout(updateNotificationCount, 500);
        }
      } catch(err){ console.error('mark all read failed', err); }
    }

    const markAllReadBtnDesk = document.getElementById('markAllRead');
    if (markAllReadBtnDesk) {
      markAllReadBtnDesk.addEventListener('click', markAllNotificationsAsRead);
    }

    // Ensure the listener exists even if header injected late
    document.addEventListener('headerLoaded', () => {
      const hdrBtn = document.getElementById('markAllRead');
      if (hdrBtn) {
        const clone = hdrBtn.cloneNode(true);
        hdrBtn.parentNode.replaceChild(clone, hdrBtn);
        clone.addEventListener('click', markAllNotificationsAsRead);
      }
    });

    // === Simple center-screen popup used by View buttons ===
    function showSimplePopup(content = "This is a popup") {
      // Remove any existing popup first
      const existing = document.querySelector('.simple-popup-overlay');
      if (existing) existing.remove();
    
      // Create overlay that always covers the viewport regardless of scrolling
      const overlay = document.createElement('div');
      overlay.className = 'simple-popup-overlay';
      Object.assign(overlay.style, {
        position: 'fixed',      // lock to viewport
        inset: '0',             // shorthand for top/right/bottom/left 0
        background: 'rgba(0,0,0,0.6)',
        display: 'grid',        // grid makes centering trivial
        placeItems: 'center',   // center both horizontally & vertically
        zIndex: 9999            // very high to sit above other fixed elements
      });
    
      // Create popup box
      const box = document.createElement('div');
      Object.assign(box.style, {
        background: '#0d1117',
        color: '#f0f6fc',
        padding: '24px 32px',
        borderRadius: '8px',
        fontSize: '18px',
        maxWidth: window.innerWidth <= 768 ? '98vw' : '95vw',
        width: window.innerWidth <= 768 ? 'auto' : '600px',
        textAlign: 'center',
        boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
        fontFamily: "'Söhne', 'Inter', sans-serif"
      });
    
      // Inject content
      if (content instanceof Node) {
        // Add CSS to make player-bubble fill full width in popup
        const style = document.createElement('style');
        style.textContent = `
          .simple-popup-overlay .player-list {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
          }
          .simple-popup-overlay .player-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 0 16px;
          }
          .simple-popup-overlay .player-bubble {
            width: 100% !important;
            max-width: none !important;
            margin: 0 48px;
          }
          @media (max-width: 768px) {
            .simple-popup-overlay .player-row {
              padding: 0 12px;
            }
            .simple-popup-overlay .player-bubble {
              width: 100% !important;
              margin: 0 6px;
            }
          }
        `;
        document.head.appendChild(style);
        box.appendChild(content);
      } else if (content) {
        box.textContent = String(content);
      }
    
      // Prevent click propagation inside the box
      box.addEventListener('click', (e) => e.stopPropagation());
    
      // Close popup when overlay area outside box is clicked
      overlay.addEventListener('click', () => overlay.remove());
    
      overlay.appendChild(box);
      // Append to <html> instead of <body> to avoid transforms on body affecting fixed positioning
      (document.documentElement || document.body).appendChild(overlay);
    }

    // === Team card builder ===
    function buildTeamCard(teamId, players) {
      const card = document.createElement("div");
      card.className = "team-card";
    
      // --- Roster construction counts at the top ---
      const counts = { QB: 0, RB: 0, WR: 0, TE: 0 };
      players.forEach(p => { if (counts[p.position] !== undefined) counts[p.position]++; });
      const rosterConstruction = document.createElement("div");
      rosterConstruction.className = "roster-construction";
      rosterConstruction.innerHTML = `<div class="roster-counts">QB${counts.QB} | RB${counts.RB} | WR${counts.WR} | TE${counts.TE}</div>`;
      card.appendChild(rosterConstruction);
    
      // --- Player list (vertical) ---
      const list = document.createElement("div");
      list.className = "player-list";
    
      // Sort players first by position (QB, RB, WR, TE) then by pick number
      const positionOrder = { QB: 0, RB: 1, WR: 2, TE: 3 };
      const playersSorted = [...players].sort((a, b) => {
        if (positionOrder[a.position] !== positionOrder[b.position]) {
          return positionOrder[a.position] - positionOrder[b.position];
        }
        return (a.pick || 0) - (b.pick || 0);
      });
    
      ["QB", "RB", "WR", "TE"].forEach(pos => {
        playersSorted.filter(p => p.position === pos).forEach(pl => {
          const row = document.createElement("div");
          row.className = "player-row";
    
          const bubble = document.createElement("div");
          bubble.className = "player-bubble";
          const stackStar = pl.stack ? 
            `<span class="stack-star ${pl.stack}">★</span>` : '';
          // Build bubble content with pick number left-aligned and player info centered
          const pickHTML = (pl.pick || pl.pick === 0) ? `<span class="pick-num">#${pl.pick}</span>` : '';
          const infoHTML = `<span class="player-info">${pl.name}${pl.team ? ` - ${pl.team}` : ''}</span>`;
          const starHTML = stackStar; // star after info for positioning via CSS
          bubble.innerHTML = `${pickHTML}${infoHTML}${starHTML}`;
          bubble.style.border = `2px solid ${getBorderColor(pl.position)}`;
    
          row.appendChild(bubble);
          list.appendChild(row);
        });
      });
    
      card.appendChild(list);
      return card;
    }

    // === Helper for border colors ===
    function getBorderColor(position, tournamentName = "") {
      // Special case: In "Rookies and Sophomores" tournament, treat TE same as WR (yellow)
      if (tournamentName === "Rookies and Sophomores" && position === "TE") {
        return "#facc15"; // WR color (yellow)
      }
      
      switch (position) {
        case "QB": return "#a855f7";
        case "RB": return "#22c55e";
        case "WR": return "#facc15";
        case "TE": return "#3b82f6";
        default: return "#999";
      }
    }

    loadProfile();
  </script>



  <footer class="legal-footer">
    <div class="footer-content">
      <div class="social-links">
        <a href="https://x.com/DraftrPass" target="_blank" rel="noopener noreferrer" title="Follow us on X">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://discord.gg/Y7hyQsfDQx" target="_blank" rel="noopener noreferrer" title="Join our Discord">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.566 18.566 0 0 0-5.487 0 12.36 12.36 0 0 0-.617-1.23A.077.077 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.07.07 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20.03 20.03 0 0 0 5.993 2.98.078.078 0 0 0 .084-.026 13.83 13.83 0 0 0 1.226-1.963.074.074 0 0 0-.041-.104 13.201 13.201 0 0 1-1.872-.878.075.075 0 0 1-.008-.125c.126-.093.252-.19.372-.287a.075.075 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.075.075 0 0 1 .079.009c.12.098.246.195.372.288a.075.075 0 0 1-.006.125c-.598.344-1.22.635-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.077.077 0 0 0 .084.028 19.963 19.963 0 0 0 6.002-2.981.076.076 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028zM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38z"/>
          </svg>
        </a>
      </div>
      <div class="legal-links">
        <a href="privacy.html" target="_blank">Privacy Policy</a>
        <a href="terms.html" target="_blank">Terms of Service</a>
      </div>
    </div>
  </footer>
  <script src="analytics.js"></script>
</body>
</html> 
