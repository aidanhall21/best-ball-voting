<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tournament - Draft or Pass</title>
  <link rel="stylesheet" href="style.css" />
  <script defer src="header.js"></script>
  <script defer src="script.js"></script>
  <script defer src="analytics.js"></script>
  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="/favicon_io/site.webmanifest">
  <link rel="shortcut icon" href="/favicon_io/favicon.ico">

  <!-- Social share metadata -->
  <meta property="og:title" content="Tournament - Draft or Pass">
  <meta property="og:description" content="Join the first Draft or Pass tournament!">
  <meta property="og:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://draftrpass.com/tournament" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Tournament - Draft or Pass">
  <meta name="twitter:description" content="Join the first Draft or Pass tournament!">
  <meta name="twitter:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta name="twitter:image:alt" content="Draft or Pass Tournament preview">
  
  <!-- Cloudflare Web Analytics -->
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "059f1f1236dc4f709c203129c35b24c2"}'></script>
  
  <!-- Cloudflare Turnstile for bot protection -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit" async defer></script>

  <style>
    /* Tournament page specific responsive improvements */
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      padding: 0;
    }

    .main-content {
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 1;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      box-sizing: border-box;
    }

    .tournament-container {
      max-width: 1000px; /* Increased from 800px for better desktop use */
      margin: 0 auto;
      padding: 1.5rem 1rem; /* Reduced from 2rem */
      width: 100%;
    }

    /* Desktop optimizations */
    @media (min-width: 1024px) {
      .tournament-container { max-width: 1100px; padding: 1.5rem 2rem; }
      .countdown-container { padding: 2.5rem 3rem; margin: 2.5rem 0; }
      .countdown-display { gap: 3rem; }
      .countdown-unit { min-width: 100px; padding: 1.5rem 1rem; }
      .tournament-info { padding: 2.5rem 3rem; margin: 3rem 0; }
      .tournament-info p { font-size: 18px; line-height: 1.6; margin-bottom: 1.25rem; }
      .tournament-tabs { margin-bottom: 3rem; justify-content: center; }
      .tournament-tab { padding: 1.25rem 2rem; font-size: 1.1rem; }
      .tournament-matchup { padding: 0; margin-bottom: 0; }
      .teams-grid { gap: 3rem; }
    }

    /* Large desktop optimization */
    @media (min-width: 1200px) {
      .tournament-container {
        max-width: 1200px; /* Use even more space on very large screens */
        padding: 1.5rem 3rem;
      }
    }

    /* Tablet adjustments */
    @media (min-width: 768px) and (max-width: 1023px) {
      .tournament-container {
        max-width: 900px;
        padding: 1.75rem 1.5rem;
      }
    }

    /* Mobile optimization */
    @media (max-width: 768px) {
      .main-content { padding: 15px 0px !important; }
      .tournament-container { max-width: 100%; padding: 1rem 0.75rem; margin: 0; }
      .team-card.tournament-team { padding: 0; }
      .tournament-info { padding: 1.5rem 1rem; margin: 1.5rem 0; }
      .tournament-matchup { padding: 0; margin-bottom: 0; }
      .tournament-title { font-size: 2rem; }
      .countdown-display { gap: 1rem; }
      .countdown-unit { min-width: 60px; padding: 0.75rem; }
      .countdown-number { font-size: 1.5rem; }
      .results-grid { grid-template-columns: 1fr; gap: 1rem; }
      .results-vs { order: 2; }
      .team-result:last-child { order: 3; }
      .teams-grid { grid-template-columns: 1fr 1fr; gap: 0.25rem !important; padding: 0 !important; align-items: start !important; }
      .team-card.tournament-team { margin-top: 0 !important; align-self: start !important; }
      .team-header { margin-top: 0 !important; }
      .team-header h4 { margin-top: 0 !important; }
      .team-header { width: 100%; max-width: 100%; box-sizing: border-box; }
      .roster-construction { width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden; }
      .player-bubble { margin-left: 2px !important; margin-right: 2px !important; }
      .team-header h4 { font-size: 16px !important; line-height: 1.2; margin-bottom: 0.25rem; margin-top: 10px !important; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .matchup-vs { order: 2; }
      .bracket-grid { gap: 1rem; }
      .bracket-round { min-width: 160px; }
      .choose-button { margin-bottom: 5px !important; }
    }

    .tournament-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .tournament-title {
      font-size: 2.5rem;
      font-weight: 700;
      color: #f0f6fc;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #58a6ff, #79c0ff, #a5f3fc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .countdown-container {
      background: rgba(88, 166, 255, 0.1);
      border: 1px solid rgba(88, 166, 255, 0.3);
      border-radius: 12px;
      padding: 2rem;
      margin: 2rem 0;
    }

    /* Countdown responsive improvements (merged into main desktop block) */

    .countdown-display {
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
      margin-top: 1.5rem;
    }

    .countdown-unit {
      background: rgba(240, 246, 252, 0.05);
      border-radius: 8px;
      padding: 1rem;
      min-width: 80px;
      text-align: center;
    }

    .countdown-number {
      font-size: 2rem;
      font-weight: 700;
      color: #58a6ff;
      display: block;
    }

    .countdown-label {
      font-size: 0.875rem;
      color: #8b949e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 0.5rem;
    }

    .tournament-info {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 2rem;
      margin: 2rem 0;
      text-align: left;
    }

    /* Tournament info responsive improvements (merged into main desktop block) */

    

    .tournament-info h3 {
      color: #f0f6fc;
      margin-bottom: 1rem;
      font-size: 1.25rem;
    }

    .tournament-info p {
      color: #8b949e;
      line-height: 1.6;
      margin-bottom: 1rem;
    }

    .select-teams-button {
      background: linear-gradient(135deg, #58a6ff, #79c0ff);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: 600;
      text-decoration: none;
      display: inline-block;
      margin-top: 1.5rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      cursor: pointer;
    }

    .select-teams-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(88, 166, 255, 0.3);
      text-decoration: none;
      color: white;
    }

    .select-teams-button:active {
      transform: translateY(0);
    }



    /* Tournament View Styles */
    .tournament-view {
      margin-top: 0rem;
    }

    .tournament-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 1rem;
      border-bottom: 1px solid rgba(240, 246, 252, 0.1);
    }

    /* Tournament tabs responsive improvements (merged into main desktop block) */

    .tournament-tab {
      background: transparent;
      border: none;
      padding: 1rem 1.5rem;
      color: #8b949e;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
    }

    .tournament-tab:hover {
      color: #f0f6fc;
      background: rgba(240, 246, 252, 0.05);
    }

    .tournament-tab.active {
      color: #58a6ff;
      border-bottom-color: #58a6ff;
    }

    .tournament-tab-content {
      display: none;
    }

    .tournament-tab-content.active {
      display: block;
    }

    .bracket-container {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 3rem 2rem;
      text-align: center;
    }

    .bracket-placeholder h3 {
      color: #f0f6fc;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .bracket-placeholder p {
      color: #8b949e;
      font-size: 1rem;
    }

    /* Hide countdown container when tournament view is active */
    .tournament-active .tournament-header {
      display: none;
    }

    .tournament-active .tournament-info {
      display: none;
    }

    /* Tournament Voting Styles */
    .tournament-matchup {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 0;
      margin-bottom: 0;
      width: 100%;
    }

    /* Tournament matchup responsive improvements (merged into main desktop block) */

    

    .matchup-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .matchup-header h3 {
      color: #f0f6fc;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .matchup-subtitle {
      color: #8b949e;
      font-size: 1rem;
    }

    .teams-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      align-items: center;
      width: 100%;
      padding: 0 2rem;
      box-sizing: border-box;
    }

    /* Tournament-specific team card styles */
    .tournament-team {
      background: rgba(240, 246, 252, 0.05);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
      width: 100%;
      box-sizing: border-box;
    }

    /* Tournament-specific player bubble styles */
    .tournament-team .player-bubble {
      width: 100%;
      margin: 0.1rem 1rem;
      box-sizing: border-box;
    }

    /* Ensure team cards fit within tournament-tab-content */
    .tournament-tab-content {
      width: 100%;
      max-width: 100%;
    }

    .teams-container {
      width: 100%;
      max-width: 100%;
    }

    .tournament-team {
      background: rgba(240, 246, 252, 0.05);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
    }

    .team-header h4 {
      color: #f0f6fc;
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
    }

    .betting-info {
      display: flex;
      flex-direction: row;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
    }

    .betting-odds {
      color: #58a6ff;
      font-size: 1rem;
      font-weight: 600;
    }

    .implied-probability {
      color: #8b949e;
      font-size: 0.8rem;
    }

    /* Vote Results Styling */
    .vote-results-display {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
    }

    .vote-success {
      margin-bottom: 2rem;
    }

    .vote-success h3 {
      color: #3fb950;
      font-size: 1.5rem;
      margin: 0;
    }

    .results-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 2rem;
      align-items: center;
      margin-bottom: 2rem;
    }

    .team-result {
      background: rgba(240, 246, 252, 0.05);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 8px;
      padding: 1.5rem;
    }

    .team-result.chosen {
      border-color: #3fb950;
      box-shadow: 0 0 0 1px rgba(63, 185, 80, 0.4);
    }

    .team-result h4 {
      color: #f0f6fc;
      margin-bottom: 1rem;
      font-size: 1.2rem;
    }

    .result-stats {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .vote-count-display {
      display: flex;
      align-items: baseline;
      justify-content: center;
      gap: 0.5rem;
    }

    .vote-number {
      font-size: 2rem;
      font-weight: bold;
      color: #58a6ff;
    }

    .vote-label {
      color: #8b949e;
      font-size: 0.9rem;
    }

    .elo-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .elo-rating {
      color: #f0f6fc;
      font-size: 0.9rem;
    }

    .elo-change {
      font-size: 0.8rem;
      font-weight: 600;
    }

    .elo-change.positive {
      color: #3fb950;
    }

    .elo-change.negative {
      color: #f85149;
    }

    .results-vs {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      color: #8b949e;
    }

    .results-vs span {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .total-votes {
      font-size: 0.8rem;
      color: #8b949e;
    }

    .next-actions {
      margin-top: 2rem;
    }

    .next-matchup-btn {
      padding: 12px 24px;
      font-size: 16px;
      background: #0969da;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .next-matchup-btn:hover {
      filter: brightness(1.1);
    }

    

    .vote-section {
      margin-top: 1rem;
    }

    .vote-count {
      margin-bottom: 1rem;
    }

    .vote-count .votes {
      font-size: 2rem;
      font-weight: bold;
      color: #58a6ff;
    }

    .votes-label {
      color: #8b949e;
      font-size: 0.9rem;
      margin-left: 0.5rem;
    }

    .votes-needed {
      color: #8b949e;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }

    .vote-btn {
      background: linear-gradient(135deg, #58a6ff, #1f6feb);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 6px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
    }

    .vote-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, #1f6feb, #0969da);
      transform: translateY(-1px);
    }

    .vote-btn:disabled {
      background: #21262d;
      color: #6e7681;
      cursor: not-allowed;
    }

    .matchup-vs {
      font-size: 1.5rem;
      font-weight: bold;
      color: #8b949e;
      text-align: center;
    }

    .vote-feedback {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      text-align: center;
      font-weight: 500;
    }

    .vote-feedback.success {
      background: rgba(46, 160, 67, 0.15);
      color: #3fb950;
      border: 1px solid rgba(46, 160, 67, 0.4);
    }

    .vote-feedback.error {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
      border: 1px solid rgba(248, 81, 73, 0.4);
    }

    .no-matchup, .error-message {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 3rem 2rem;
      text-align: center;
    }

    .no-matchup h3, .error-message h3 {
      color: #f0f6fc;
      margin-bottom: 1rem;
    }

    .no-matchup p, .error-message p {
      color: #8b949e;
      margin-bottom: 1rem;
    }

    /* March Madness Style Bracket */
    .bracket-container {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 12px;
      padding: 2rem;
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Desktop bracket layout */
    @media (min-width: 1024px) {
      .march-madness-bracket {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        grid-template-rows: 1fr auto 1fr;
        gap: 3rem;
        min-height: 800px;
        width: 100%;
        position: relative;
      }

      .bracket-region {
        display: flex;
        flex-direction: column;
        position: relative;
      }

      .bracket-region.top-left {
        grid-column: 1;
        grid-row: 1;
        justify-content: flex-end;
      }

      .bracket-region.bottom-left {
        grid-column: 1;
        grid-row: 3;
        justify-content: flex-start;
      }

      .bracket-region.top-right {
        grid-column: 3;
        grid-row: 1;
        justify-content: flex-end;
      }

      .bracket-region.bottom-right {
        grid-column: 3;
        grid-row: 3;
        justify-content: flex-start;
      }

      .bracket-center {
        grid-column: 2;
        grid-row: 1 / 4;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-width: 300px;
      }

      .region-rounds {
        display: flex;
        gap: 2rem;
        height: 100%;
      }

      .bracket-round {
        min-width: 180px;
        display: flex;
        flex-direction: column;
      }

      .round-title {
        color: #f0f6fc;
        text-align: center;
        margin-bottom: 1rem;
        font-size: 1rem;
        font-weight: 600;
        position: sticky;
        top: 0;
        background: rgba(13, 17, 23, 0.95);
        padding: 0.5rem;
        border-radius: 6px;
      }

      .round-matchups {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        flex: 1;
        gap: 0.75rem;
      }

      /* Spacing adjustments for each round */
      .round-1 .round-matchups {
        gap: 0.5rem;
      }

      .round-2 .round-matchups {
        gap: 1rem;
      }

      .round-3 .round-matchups {
        gap: 2rem;
      }

      .round-4 .round-matchups {
        gap: 4rem;
      }

      .round-5 .round-matchups {
        gap: 8rem;
      }

      .round-6 .round-matchups {
        gap: 16rem;
      }

      /* Connecting lines between rounds */
      .bracket-matchup {
        position: relative;
      }

      .bracket-matchup::after {
        content: '';
        position: absolute;
        right: -1rem;
        top: 50%;
        width: 2rem;
        height: 2px;
        background: rgba(240, 246, 252, 0.2);
        transform: translateY(-50%);
      }

      .matchup-id-badge {
        position: absolute;
        top: -8px;
        left: 4px;
        background: rgba(33, 139, 255, 0.8);
        color: white;
        font-size: 10px;
        font-weight: bold;
        padding: 2px 6px;
        border-radius: 4px;
        z-index: 10;
        pointer-events: none;
      }

      /* Right region flows inward, so lines go left */
      .bracket-region.top-right .bracket-matchup::after,
      .bracket-region.bottom-right .bracket-matchup::after {
        left: -1rem;
        right: auto;
      }

      /* No connecting lines on the last round of each region */
      .bracket-round:last-child .bracket-matchup::after {
        display: none;
      }

      /* Vertical connectors for multiple matchups feeding into next round */
      .round-matchups {
        position: relative;
      }

      .round-matchups::before {
        content: '';
        position: absolute;
        right: -2rem;
        top: 25%;
        bottom: 25%;
        width: 2px;
        background: rgba(240, 246, 252, 0.2);
      }

      /* Right regions have vertical connectors on the left */
      .bracket-region.top-right .round-matchups::before,
      .bracket-region.bottom-right .round-matchups::before {
        left: -2rem;
        right: auto;
      }

      /* No vertical connectors on the last round */
      .bracket-round:last-child .round-matchups::before {
        display: none;
      }
    }

    /* Fallback for smaller screens */
    .bracket-grid {
      display: flex;
      gap: 2rem;
      overflow-x: auto;
      padding: 1rem 0;
    }

    @media (max-width: 1023px) {
      .march-madness-bracket {
        display: none;
      }
      .bracket-grid {
        display: flex;
      }
    }

    @media (min-width: 1024px) {
      .bracket-grid {
        display: none;
      }
    }

    .bracket-round {
      min-width: 200px;
      flex-shrink: 0;
    }

    .bracket-matchup {
      background: rgba(240, 246, 252, 0.03);
      border: 1px solid rgba(240, 246, 252, 0.1);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      position: relative;
    }

    .bracket-matchup.active {
      border-color: #58a6ff;
      box-shadow: 0 0 0 1px rgba(88, 166, 255, 0.4);
    }

    .bracket-team {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      margin-bottom: 0.2rem;
      font-size: 0.85rem;
    }

    .bracket-team.winner {
      background: rgba(46, 160, 67, 0.15);
      color: #3fb950;
      font-weight: 600;
    }

    .bracket-team.active {
      background: rgba(88, 166, 255, 0.15);
      color: #58a6ff;
    }

    .bracket-team.empty {
      color: #6e7681;
      font-style: italic;
    }

    .team-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .team-votes {
      font-weight: bold;
      font-size: 0.8rem;
      min-width: 20px;
      text-align: right;
    }

    .bracket-vs {
      text-align: center;
      color: #8b949e;
      font-size: 0.7rem;
      margin: 0.2rem 0;
    }

    /* Region titles */
    .region-title {
      color: #58a6ff;
      font-size: 1.1rem;
      font-weight: 600;
      text-align: center;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Center championship area */
    .championship-area {
      background: rgba(88, 166, 255, 0.1);
      border: 2px solid rgba(88, 166, 255, 0.3);
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
      min-width: 250px;
    }

    .championship-title {
      color: #f0f6fc;
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      background: linear-gradient(135deg, #58a6ff, #79c0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .finals-matchup {
      background: rgba(240, 246, 252, 0.05);
      border: 2px solid rgba(88, 166, 255, 0.2);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .champion-display {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 193, 7, 0.1));
      border: 2px solid rgba(255, 215, 0, 0.5);
      border-radius: 10px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .champion-title {
      color: #ffd700;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .champion-name {
      color: #f0f6fc;
      font-size: 1.3rem;
      font-weight: 700;
    }

    
    /* Owner info styles (matching draftorpass.html) */
    .owner-info {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }

    .owner-info.winner {
      background: rgba(40, 167, 69, 0.2);
      border-color: rgba(40, 167, 69, 0.4);
      box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
    }

    .owner-info.loser {
      background: rgba(220, 53, 69, 0.2);
      border-color: rgba(220, 53, 69, 0.4);
      box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
    }

    .owner-stats {
      font-size: 12px;
      color: #ccc;
      line-height: 1.4;
      word-wrap: break-word;
      margin-bottom: 6px;
    }
    
    .votes-needed {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      text-align: center;
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
    }

    .owner-info.winner .owner-stats {
      color: #d4edda;
    }

    .owner-info.loser .owner-stats {
      color: #f8d7da;
    }

    /* Next button styles (matching draftorpass.html) */
    .next-button {
      background: linear-gradient(45deg, #28a745, #20c997);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin: 16px auto;
      display: block;
      transition: background 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .next-button:hover {
      background: linear-gradient(45deg, #218838, #17a2b8);
      box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    }

    .next-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
  </style>
</head>

<body>
  <!-- Hidden Turnstile container -->
  <div id="cf-container" style="display:none;"></div>

  <main class="main-content">
    <div class="tournament-container">
      <div class="tournament-header">
        <h1 class="tournament-title" id="tournamentTitle">Tournament Starts In</h1>
        
        <div class="countdown-container">
          <div class="countdown-display" id="countdown">
            <div class="countdown-unit">
              <span class="countdown-number" id="days">--</span>
              <span class="countdown-label">Days</span>
            </div>
            <div class="countdown-unit">
              <span class="countdown-number" id="hours">--</span>
              <span class="countdown-label">Hours</span>
            </div>
            <div class="countdown-unit">
              <span class="countdown-number" id="minutes">--</span>
              <span class="countdown-label">Minutes</span>
            </div>
            <div class="countdown-unit">
              <span class="countdown-number" id="seconds">--</span>
              <span class="countdown-label">Seconds</span>
            </div>
          </div>
        </div>
      </div>

      <div class="tournament-info">
        <h3>Tournament Details</h3>
        <p>DraftrPass is proud to present our first ever elimination tournament! 256 teams will enter and one winner will be crowned the best team drafted in The Puppy. Think your teams stack up? Select up to four of your best teams for submission into the contest, then check back on Friday, August 8th when voting begins.</p>
        
        <div class="team-counter">
          <span class="counter-label">Teams Entered:</span>
          <span class="counter-display">
            <span id="teamsCount">--</span> / <span class="max-teams">256</span>
          </span>
        </div>
        
        <p><strong>Start Time:</strong> Friday, August 8th, 2025 at 12:00 PM ET</p>
        <p><strong>Format:</strong> 256 teams going 8 rounds in a single elimination bracket. Each matchup is a best of 7.</p>
        
        <a href="/profile.html" class="select-teams-button">Select Your Teams</a>
      </div>

      <!-- Tournament View (hidden initially) -->
      <div id="tournamentView" class="tournament-view" style="display: none;">
        <div class="tournament-tabs">
          <button class="tournament-tab active" data-tab="voting">Draft or Pass</button>
          <button class="tournament-tab" data-tab="bracket">Bracket View</button>
        </div>
        
        <div id="votingTab" class="tournament-tab-content active">
          <div id="teamsContainer" class="teams-container">
            <div class="loading-indicator">Loading tournament teams…</div>
          </div>
        </div>
        
        <div id="bracketTab" class="tournament-tab-content">
          <div class="bracket-container">
            <div class="bracket-placeholder">
              <h3>Tournament Bracket</h3>
              <p>Bracket view coming soon...</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // === TOURNAMENT CONFIGURATION ===
    // 
    // FOR FUTURE TOURNAMENTS:
    // 1. Set FORCE_COUNTDOWN_MODE = true to show countdown
    // 2. Update tournamentStart date to the new tournament start time
    // 3. Update tournament details in the HTML below
    // 4. When tournament begins, set FORCE_COUNTDOWN_MODE = false
    //
    const FORCE_COUNTDOWN_MODE = false;
    
    // Global tournament configuration
    let tournamentData = null;
    let tournamentStart = null; // Will be set dynamically from database

    let tournamentViewShown = false;
    let countdownInterval;
    let nominationsCountInterval;
    
    // Load current tournament info
    async function loadCurrentTournament() {
      try {
        const response = await fetch('/api/tournament/current');
        const data = await response.json();
                    tournamentData = data.tournament;
        
        if (tournamentData) {
          
          // Set tournament start time from database
          if (tournamentData.scheduled_start_time) {
            tournamentStart = new Date(tournamentData.scheduled_start_time);
          } else {
            console.warn('No scheduled start time found for tournament');
          }
          
          // Update page title and headers
          document.getElementById('tournamentTitle').textContent = `${tournamentData.name} Tournament Starts In`;
          document.title = `${tournamentData.name} Tournament - Draft or Pass`;
          return tournamentData;
        } else {
          document.getElementById('tournamentTitle').textContent = 'No Tournament Active';
          return null;
        }
      } catch (err) {
        console.error('Failed to load current tournament:', err);
        document.getElementById('tournamentTitle').textContent = 'Error Loading Tournament';
        return null;
      }
    }

    function updateCountdown() {
      if (!tournamentStart) {
        // Tournament start time not loaded yet
        document.getElementById('days').textContent = '--';
        document.getElementById('hours').textContent = '--';
        document.getElementById('minutes').textContent = '--';
        document.getElementById('seconds').textContent = '--';
        return;
      }
      
      const now = new Date();
      const timeDiff = tournamentStart - now;

      if (timeDiff <= 0 && !FORCE_COUNTDOWN_MODE && !tournamentViewShown) {
        // Tournament has started - check if tournament is active before showing tournament view
        if (tournamentData && tournamentData.status === 'active') {
          clearInterval(countdownInterval); // Stop the countdown
          showTournamentView();
          return;
        } else {
          // Tournament exists but is not active yet - show zeros and stop countdown
          console.log('Tournament countdown ended but tournament status is not active:', tournamentData?.status);
          document.getElementById('days').textContent = '00';
          document.getElementById('hours').textContent = '00';
          document.getElementById('minutes').textContent = '00';
          document.getElementById('seconds').textContent = '00';
          clearInterval(countdownInterval); // Stop the countdown to prevent going negative
          return;
        }
      }

      // Only calculate and display countdown if time is remaining
      if (timeDiff > 0) {
        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

        document.getElementById('days').textContent = days.toString().padStart(2, '0');
        document.getElementById('hours').textContent = hours.toString().padStart(2, '0');
        document.getElementById('minutes').textContent = minutes.toString().padStart(2, '0');
        document.getElementById('seconds').textContent = seconds.toString().padStart(2, '0');
      } else {
        // Time has expired, show zeros
        document.getElementById('days').textContent = '00';
        document.getElementById('hours').textContent = '00';
        document.getElementById('minutes').textContent = '00';
        document.getElementById('seconds').textContent = '00';
        clearInterval(countdownInterval); // Stop the countdown
      }
    }

    // Tournament view functions
    async function showTournamentView() {
      // Prevent multiple calls to showTournamentView
      if (tournamentViewShown) {
        console.log('Tournament view already shown, skipping...');
        return;
      }
      
      // Set flag immediately to prevent race conditions
      tournamentViewShown = true;
      
      // Stop nominations count polling since tournament view is now showing
      if (nominationsCountInterval) {
        clearInterval(nominationsCountInterval);
        nominationsCountInterval = null;
        console.log('Stopped nominations count polling - tournament view activated');
      }
      
      // Ensure tournament is loaded and active before proceeding
      if (!tournamentData) {
        await loadCurrentTournament();
      }
      
      // Double-check tournament status before showing tournament view
      if (!tournamentData || tournamentData.status !== 'active') {
        console.error('Cannot show tournament view - tournament is not active:', tournamentData?.status);
        // Reset flag if we're not actually showing the view
        tournamentViewShown = false;
        
        // Restart nominations polling since we're not showing tournament view
        if (!nominationsCountInterval && tournamentData && tournamentData.status === 'setup') {
          nominationsCountInterval = setInterval(loadNominationsCount, 30000);
          console.log('Restarted nominations count polling - tournament view failed to activate');
        }
        return;
      }
      
      // Hide countdown elements and show tournament view
      document.querySelector('.tournament-container').classList.add('tournament-active');
      document.getElementById('tournamentView').style.display = 'block';
      
      // Update page title
      document.querySelector('.tournament-title').textContent = 'Tournament Live';

      
      // Setup tab switching
      setupTournamentTabs();

      
      // Initialize tournament system manually
      
      // Ensure tournament is loaded before proceeding
      if (!tournamentData) {
        await loadCurrentTournament();
        if (!tournamentData) {
          console.error('No tournament available for live view');
          return;
        }
      }

      
      // Call tournament functions directly
      
      // Load current matchup
      fetch(`/api/tournament/current-matchup/${tournamentData.id}`)
          .then(response => response.json())
          .then(data => {
            const container = document.getElementById('teamsContainer');
            
            // Handle special cases first
            if (data.requiresLogin) {
              container.innerHTML = `
                <div class="no-matchup">
                  <h3>Authentication Required</h3>
                  <p>You must be <a href="/upload.html" style="color: #58a6ff; text-decoration: underline;">logged in</a> to vote in the tournament</p>
                </div>
              `;
              return;
            }
            
            if (data.allVoted) {
              container.innerHTML = `
                <div class="no-matchup">
                  <h3>Round Complete</h3>
                  <p>${data.message}</p>
                </div>
              `;
              return;
            }
            
            if (data.matchup) {
              // Display matchup directly
              const matchup = data.matchup;
              const team1VotesNeeded = (matchup.votes_needed || 4) - matchup.team1_votes;
              const team2VotesNeeded = (matchup.votes_needed || 4) - matchup.team2_votes;
              
              // Generate roster HTML for each team
              const generateRosterHTML = (roster) => {
                if (!roster || !roster.length) return '<div class="no-roster">No roster data available</div>';
                
                // Count positions for roster construction
                const counts = { QB: 0, RB: 0, WR: 0, TE: 0 };
                roster.forEach(p => { if (counts[p.position] !== undefined) counts[p.position]++; });
                
                const rosterConstructionHTML = `
                  <div class="roster-construction">
                    <div class="roster-counts">QB${counts.QB} | RB${counts.RB} | WR${counts.WR} | TE${counts.TE}</div>
                  </div>
                `;
                
                // Generate player list HTML
                const playerListHTML = roster.map(player => {
                  const stackStar = player.stack ? `<span class="stack-star ${player.stack}">★</span>` : '';
                  const pickHTML = (player.pick || player.pick === 0) ? `<span class="pick-num">#${player.pick}</span>` : '';
                  const infoHTML = `<span class="player-info">${player.name}${player.team ? ` - ${player.team}` : ''}</span>`;
                  
                  return `
                    <div class="player-row">
                      <div class="player-bubble" style="border: 2px solid ${getBorderColor(player.position)}">
                        ${pickHTML}${infoHTML}${stackStar}
                      </div>
                    </div>
                  `;
                }).join('');
                
                return `
                  ${rosterConstructionHTML}
                  <div class="player-list">
                    ${playerListHTML}
                  </div>
                `;
              };
              
              // Function to get border color for positions (matching main interface colors)
              const getBorderColor = (position) => {
                const colors = {
                  QB: '#a855f7', // Purple (matching CSS)
                  RB: '#22c55e', // Green (matching CSS)
                  WR: '#facc15', // Yellow (matching CSS)
                  TE: '#3b82f6'  // Blue (matching CSS)
                };
                return colors[position] || '#999999';
              };

              container.innerHTML = `
                <div class="tournament-matchup">
                  <div class="matchup-header">
                    <h3>Round ${matchup.round_number} - Match ${matchup.bracket_position}</h3>
                    <p class="matchup-subtitle">First to ${matchup.votes_needed || 4} votes wins!</p>
                  </div>
                  
              <div class="teams-grid">
                <div class="team-card tournament-team" style="width:100%;" data-team-id="${matchup.team1_id}">
                      <div class="team-header">
                        <h4>${matchup.team1_username}</h4>
                        <div class="betting-info">
                          <span class="betting-odds">${matchup.team1_odds > 0 ? '+' : ''}${matchup.team1_odds}</span>
                          <span class="implied-probability">${matchup.team1_probability}% implied</span>
                        </div>
                      </div>
                      
                      ${generateRosterHTML(matchup.team1_roster)}
                      
                      <div class="vote-section">
                        <button class="choose-button" onclick="castTournamentVote(${matchup.id}, '${matchup.team1_id}')" 
                                ${team1VotesNeeded <= 0 || team2VotesNeeded <= 0 ? 'disabled' : ''}>
                          <span>⬅️</span> Choose
                        </button>
                      </div>
                    </div>
                
                <div class="team-card tournament-team" style="width:100%;" data-team-id="${matchup.team2_id}">
                      <div class="team-header">
                        <h4>${matchup.team2_username}</h4>
                        <div class="betting-info">
                          <span class="betting-odds">${matchup.team2_odds > 0 ? '+' : ''}${matchup.team2_odds}</span>
                          <span class="implied-probability">${matchup.team2_probability}% implied</span>
                        </div>
                      </div>
                      
                      ${generateRosterHTML(matchup.team2_roster)}
                      
                      <div class="vote-section">
                        <button class="choose-button" onclick="castTournamentVote(${matchup.id}, '${matchup.team2_id}')"
                                ${team2VotesNeeded <= 0 || team1VotesNeeded <= 0 ? 'disabled' : ''}>
                          Choose <span>➡️</span>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              `;
            } else {
              container.innerHTML = `
                <div class="no-matchup">
                  <h3>Tournament Status</h3>
                  <p>${data.message || 'No active matchup at this time.'}</p>
                </div>
              `;
            }
          })
          .catch(error => {
            console.error('Error loading matchup:', error);
            document.getElementById('teamsContainer').innerHTML = `
              <div class="error-message">
                <h3>Error</h3>
                <p>Failed to load current matchup</p>
              </div>
            `;
          });
        
      // Load tournament bracket  
      fetch(`/api/tournament/bracket/${tournamentData.id}`)
          .then(response => response.json())
          .then(data => {
            const bracketContainer = document.querySelector('.bracket-container');
            if (data.bracket && Object.keys(data.bracket).length > 0) {
              generateMarchMadnessBracket(data.bracket, bracketContainer);
            } else {
              bracketContainer.innerHTML = `
                <div class="bracket-placeholder">
                  <h3>Tournament Bracket</h3>
                  <p>No bracket data available.</p>
                </div>
              `;
            }
          })
          .catch(error => {
            console.error('Error loading bracket:', error);
          });
    }
    
    // Generate March Madness style bracket
    function generateMarchMadnessBracket(bracket, container) {
      const rounds = Object.keys(bracket).sort((a, b) => parseInt(a) - parseInt(b));
      const totalRounds = rounds.length;
      
      // For 256 teams, we expect 8 rounds total
      if (totalRounds !== 8) {
        // Fallback to simple bracket for non-256 team tournaments
        generateSimpleBracket(bracket, container);
        return;
      }
      
      // Organize matchups by regions (assuming 4 regions of 64 teams each)
      const regions = organizeByRegions(bracket, rounds);
      
      let bracketHTML = `
        <div class="march-madness-bracket">
          <!-- Top Left Region -->
          <div class="bracket-region top-left">
            <div class="region-title">Midwest</div>
            <div class="region-rounds">
              ${generateRegionRounds(regions.topLeft, 'left')}
            </div>
          </div>
          
          <!-- Top Right Region -->
          <div class="bracket-region top-right">
            <div class="region-title">East</div>
            <div class="region-rounds">
              ${generateRegionRounds(regions.topRight, 'right')}
            </div>
          </div>
          
          <!-- Bottom Left Region -->
          <div class="bracket-region bottom-left">
            <div class="region-title">West</div>
            <div class="region-rounds">
              ${generateRegionRounds(regions.bottomLeft, 'left')}
            </div>
          </div>
          
          <!-- Bottom Right Region -->
          <div class="bracket-region bottom-right">
            <div class="region-title">South</div>
            <div class="region-rounds">
              ${generateRegionRounds(regions.bottomRight, 'right')}
            </div>
          </div>
          
          <!-- Center Championship Area -->
          <div class="bracket-center">
            ${generateChampionshipArea(regions.championship)}
          </div>
        </div>
        
        <!-- Fallback for mobile -->
        <div class="bracket-grid">
          ${generateSimpleBracketContent(bracket)}
        </div>
      `;
      
      container.innerHTML = bracketHTML;
    }
    
    // Organize bracket data by regions
    function organizeByRegions(bracket, rounds) {
      const regions = {
        topLeft: {},
        topRight: {},
        bottomLeft: {},
        bottomRight: {},
        championship: {}
      };
      
      rounds.forEach(round => {
        const roundNum = parseInt(round);
        const matchups = bracket[round];
        
        if (roundNum <= 6) {
          // Regional rounds (1-6)
          regions.topLeft[round] = matchups.filter((_, i) => i < matchups.length / 4);
          regions.topRight[round] = matchups.filter((_, i) => i >= matchups.length / 4 && i < matchups.length / 2);
          regions.bottomLeft[round] = matchups.filter((_, i) => i >= matchups.length / 2 && i < (3 * matchups.length) / 4);
          regions.bottomRight[round] = matchups.filter((_, i) => i >= (3 * matchups.length) / 4);
        } else {
          // Championship rounds (7-8)
          regions.championship[round] = matchups;
        }
      });
      
      return regions;
    }
    
    // Generate rounds for a region
    function generateRegionRounds(regionData, direction) {
      const rounds = Object.keys(regionData).sort((a, b) => {
        // For right regions, reverse the order to flow inward
        return direction === 'right' ? parseInt(b) - parseInt(a) : parseInt(a) - parseInt(b);
      });
      
      return rounds.map(round => {
        const roundNumber = parseInt(round);
        const roundName = getRoundName(roundNumber, 8);
        const matchups = regionData[round];
        
        return `
          <div class="bracket-round round-${roundNumber}">
            <h4 class="round-title">${roundName}</h4>
            <div class="round-matchups">
              ${matchups.map(matchup => generateMatchupHTML(matchup)).join('')}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Generate championship area
    function generateChampionshipArea(championshipData) {
      const rounds = Object.keys(championshipData).sort((a, b) => parseInt(a) - parseInt(b));
      
      if (rounds.length === 0) {
        return `
          <div class="championship-area">
            <h3 class="championship-title">Championship</h3>
            <p style="color: #8b949e;">Championship matchups will appear here</p>
          </div>
        `;
      }
      
      let championshipHTML = `
        <div class="championship-area">
          <h3 class="championship-title">Championship</h3>
      `;
      
      rounds.forEach(round => {
        const roundNumber = parseInt(round);
        const roundName = roundNumber === 8 ? 'Final' : 'Semifinals';
        const matchups = championshipData[round];
        
        championshipHTML += `
          <div class="championship-round">
            <h4 style="color: #f0f6fc; margin-bottom: 1rem;">${roundName}</h4>
            ${matchups.map(matchup => {
              if (roundNumber === 8 && matchup.winner_id) {
                return `
                  <div class="finals-matchup">
                    ${generateMatchupHTML(matchup)}
                  </div>
                  <div class="champion-display">
                    <div class="champion-title">🏆 Champion</div>
                    <div class="champion-name">${matchup.winner_id === matchup.team1_id ? matchup.team1_username : matchup.team2_username}</div>
                  </div>
                `;
              } else {
                return `<div class="finals-matchup">${generateMatchupHTML(matchup)}</div>`;
              }
            }).join('')}
          </div>
        `;
      });
      
      championshipHTML += '</div>';
      return championshipHTML;
    }
    
    // Generate matchup HTML
    function generateMatchupHTML(matchup) {
      const team1Status = matchup.winner_id === matchup.team1_id ? 'winner' : 
                         (matchup.status === 'active' ? 'active' : '');
      const team2Status = matchup.winner_id === matchup.team2_id ? 'winner' : 
                         (matchup.status === 'active' ? 'active' : '');
      
      // Only add click handler if both teams are present
      const clickable = matchup.team1_id && matchup.team2_id;
      const clickHandler = clickable ? `onclick="showMatchupPopup(${matchup.id})"` : '';
      const clickableClass = clickable ? 'clickable' : '';
      
      return `
        <div class="bracket-matchup ${matchup.status} ${clickableClass}" ${clickHandler} data-matchup-id="${matchup.id}">
          <div class="matchup-id-badge">ID: ${matchup.id}</div>
          <div class="bracket-team ${team1Status}">
            <span class="team-name">${matchup.team1_username || 'TBD'}</span>
            <span class="team-votes">${matchup.team1_votes || 0}</span>
          </div>
          <div class="bracket-vs">vs</div>
          <div class="bracket-team ${team2Status}">
            <span class="team-name">${matchup.team2_username || 'TBD'}</span>
            <span class="team-votes">${matchup.team2_votes || 0}</span>
          </div>
        </div>
      `;
    }
    
    // Get round name based on round number
    function getRoundName(roundNumber, totalRounds) {
      const roundsFromEnd = totalRounds - roundNumber + 1;
      switch (roundsFromEnd) {
        case 1: return 'Final';
        case 2: return 'Semifinals';
        case 3: return 'Quarterfinals';
        case 4: return 'Sweet 16';
        case 5: return 'Round of 32';
        case 6: return 'Round of 64';
        case 7: return 'Round of 128';
        case 8: return 'Round of 256';
        default: return `Round ${roundNumber}`;
      }
    }
    
    // Fallback simple bracket generator
    function generateSimpleBracket(bracket, container) {
      container.innerHTML = `<div class="bracket-grid">${generateSimpleBracketContent(bracket)}</div>`;
    }
    
    // Generate simple bracket content
    function generateSimpleBracketContent(bracket) {
      const rounds = Object.keys(bracket).sort((a, b) => parseInt(a) - parseInt(b));
      
      return rounds.map(round => {
        const roundNumber = parseInt(round);
        const roundName = getRoundName(roundNumber, rounds.length);
        const matchups = bracket[round];
        
        return `
          <div class="bracket-round">
            <h4 class="round-title">${roundName}</h4>
            <div class="round-matchups">
              ${matchups.map(matchup => generateMatchupHTML(matchup)).join('')}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Cast tournament vote (exactly like draftorpass.html)
    window.castTournamentVote = async function(matchupId, teamId) {
      
      // Get matchup data to determine winner/loser
      const currentMatchup = document.querySelector('.tournament-matchup');
      if (!currentMatchup) {
        console.error('No active matchup found');
        return;
      }
      
      // Get team IDs and cards from the DOM
      const team1Card = currentMatchup.querySelector('.team-card[data-team-id]:first-of-type');
      const team2Card = currentMatchup.querySelector('.team-card[data-team-id]:last-of-type');
      const team1Id = team1Card?.dataset.teamId;
      const team2Id = team2Card?.dataset.teamId;
      
      if (!team1Id || !team2Id) {
        console.error('Could not determine team IDs');
        return;
      }
      
      // Determine winner and loser for /versus call
      const winnerId = teamId;
      const loserId = teamId === team1Id ? team2Id : team1Id;
      const isTeam1Winner = winnerId === team1Id;
      
      
      // Get choose buttons
      const chooseBtn1 = team1Card.querySelector('.choose-button');
      const chooseBtn2 = team2Card.querySelector('.choose-button');
      
      // Disable both buttons immediately to prevent double-clicks
      chooseBtn1.disabled = true;
      chooseBtn2.disabled = true;
      
      // Show immediate winner/loser state (like draftorpass.html)
      if (isTeam1Winner) {
        chooseBtn1.innerHTML = "<span>⬅️</span> Winner!";
        chooseBtn2.innerHTML = "Loser";
      } else {
        chooseBtn2.innerHTML = "Winner! <span>➡️</span>";
        chooseBtn1.innerHTML = "<span>⬅️</span> Loser";
      }
      
      // Create owner info sections if they don't exist (like draftorpass.html)
      let ownerInfo1 = team1Card.querySelector('.owner-info');
      let ownerInfo2 = team2Card.querySelector('.owner-info');
      
      if (!ownerInfo1) {
        ownerInfo1 = document.createElement('div');
        ownerInfo1.className = 'owner-info';
        // Insert before the vote-section div (which contains the choose button)
        const voteSection1 = team1Card.querySelector('.vote-section');
        if (voteSection1) {
          team1Card.insertBefore(ownerInfo1, voteSection1);
        } else {
          team1Card.appendChild(ownerInfo1);
        }
      }
      if (!ownerInfo2) {
        ownerInfo2 = document.createElement('div');
        ownerInfo2.className = 'owner-info';
        // Insert before the vote-section div (which contains the choose button)
        const voteSection2 = team2Card.querySelector('.vote-section');
        if (voteSection2) {
          team2Card.insertBefore(ownerInfo2, voteSection2);
        } else {
          team2Card.appendChild(ownerInfo2);
        }
      }
      
      // Clear any existing highlight classes
      ownerInfo1.classList.remove('winner', 'loser');
      ownerInfo2.classList.remove('winner', 'loser');
      
      // Add winner/loser classes
      if (isTeam1Winner) {
        ownerInfo1.classList.add('winner');
        ownerInfo2.classList.add('loser');
      } else {
        ownerInfo2.classList.add('winner');
        ownerInfo1.classList.add('loser');
      }
      
      // Show loading state while voting completes
      ownerInfo1.innerHTML = `<div class="owner-stats">Voting...</div>`;
      ownerInfo2.innerHTML = `<div class="owner-stats">Voting...</div>`;
      
      // Background network calls (like draftorpass.html)
      (async () => {
        try {
          // Step 1: Call /versus first
          let captchaToken;
          try {
            captchaToken = await getCaptchaToken();
          } catch (err) {
            console.error('❌ Unable to obtain Turnstile token:', err);
            return;
          }
          
          const versusResponse = await fetch('/versus', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              winnerId: winnerId,
              loserId: loserId,
              captcha: captchaToken
            })
          });
          
          
          if (!versusResponse.ok) {
            const errorText = await versusResponse.text();
            console.error(`❌ Versus vote failed (${versusResponse.status}): ${errorText}`);
            return;
          }
          
          
          // Step 2: If /versus succeeded, log to tournament system
          const tournamentResponse = await fetch('/api/tournament/vote', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              matchupId: parseInt(matchupId),
              teamId: teamId
            })
          });
          
          const tournamentData = await tournamentResponse.json();
          
          if (tournamentData.success) {
            
            // Use the vote count data from the tournament vote response
            
            // Handle both response structures: 
            // - Ongoing matchup: votes directly on tournamentData
            // - Completed matchup: votes under tournamentData.voteCount
            let team1Votes, team2Votes, votesNeeded;
            
            if (tournamentData.voteCount) {
              // Completed matchup structure
              team1Votes = tournamentData.voteCount.team1_votes || 0;
              team2Votes = tournamentData.voteCount.team2_votes || 0;
              votesNeeded = tournamentData.voteCount.votes_needed || 4;
            } else if (tournamentData.team1_votes !== undefined && tournamentData.team2_votes !== undefined) {
              // Ongoing matchup structure
              team1Votes = tournamentData.team1_votes || 0;
              team2Votes = tournamentData.team2_votes || 0;
              votesNeeded = tournamentData.votes_needed || 4;
            }
            
            if (team1Votes !== undefined && team2Votes !== undefined) {
              const team1VotesNeeded = Math.max(0, votesNeeded - team1Votes);
              const team2VotesNeeded = Math.max(0, votesNeeded - team2Votes);
              
              // Display updated vote counts in owner-info sections
              ownerInfo1.innerHTML = `
                <div class="votes-needed">
                  <strong>${team1Votes}</strong> votes | ${team1VotesNeeded > 0 ? `${team1VotesNeeded} more needed` : 'WINNER!'}
                </div>
              `;
              
              ownerInfo2.innerHTML = `
                <div class="votes-needed">
                  <strong>${team2Votes}</strong> votes | ${team2VotesNeeded > 0 ? `${team2VotesNeeded} more needed` : 'WINNER!'}
                </div>
              `;
              
              // Show next matchup button
              showNextMatchupButton();
            } else {
              console.error('No vote count data in tournament response');
              showNextMatchupButton();
            }
              
          } else {
            console.error('❌ Tournament vote failed:', tournamentData.error);
            // Still show next button even if tournament vote failed
            showNextMatchupButton();
          }
          
        } catch (error) {
          console.error('💥 Background vote processing failed:', error);
          console.error('Error stack:', error.stack);
          // Still show next button even if something failed
          showNextMatchupButton();
        }
      })().then(() => {
        console.log('🏁 Background network calls completed');
      }).catch(err => {
        console.error('🚨 Background network calls promise rejected:', err);
        // Fallback: show next button
        showNextMatchupButton();
      });
    };
    
    // Turnstile widget management (matching main script.js)
    let tournamentWidgetId = null;
    let pendingChallenges = 0;
    
    // Add captcha token function (exactly matching main script.js implementation)
    function getCaptchaToken() {
      return new Promise((resolve, reject) => {
        if (!turnstile || typeof turnstile.render !== 'function') {
          return reject(new Error('Turnstile not loaded'));
        }

        // Strict limit to prevent Cloudflare errors - only allow 1 concurrent challenge
        if (pendingChallenges > 0) {
          return reject(new Error('Too many concurrent challenges'));
        }

        pendingChallenges++;

        // Always reset the widget if it exists before executing
        if (tournamentWidgetId) {
          try {
            turnstile.reset(tournamentWidgetId);
          } catch (e) {
            console.warn('Failed to reset widget, removing and recreating:', e);
            try { 
              turnstile.remove(tournamentWidgetId); 
            } catch (removeErr) { 
              console.warn('Failed to remove widget:', removeErr);
            }
            tournamentWidgetId = null;
          }
        }

        // Create new widget if needed
        if (!tournamentWidgetId) {
          const container = document.getElementById('cf-container');
          if (!container) {
            pendingChallenges--;
            return reject(new Error('Turnstile container not found'));
          }
          
          try {
            tournamentWidgetId = turnstile.render(container, {
              sitekey: window.TURNSTILE_SITE_KEY,
              action: 'vote', // Identifier for analytics
              execution: 'execute', // Only execute when explicitly called
              size: 'invisible', // Keep it invisible
              theme: 'auto', // Respect user's theme preference
              retry: 'auto', // Auto-retry on failure
              'retry-interval': 8000, // 8 second retry interval
              'refresh-expired': 'auto', // Auto-refresh expired tokens
              callback: () => {}, // Empty callback - we'll use execute's callback
              'expired-callback': () => {
                console.log('Turnstile token expired');
              },
              'error-callback': (error) => {
                console.error('Turnstile widget error:', error);
              },
              'timeout-callback': () => {
                console.warn('Turnstile challenge timed out');
              },
              'before-interactive-callback': () => {
                console.log('Turnstile entering interactive mode');
              },
              'after-interactive-callback': () => {
                console.log('Turnstile left interactive mode');
              },
              'unsupported-callback': () => {
                console.error('Turnstile not supported in this browser');
              }
            });
          } catch (e) {
            pendingChallenges--;
            return reject(new Error('Failed to create Turnstile widget: ' + e.message));
          }
        }

        // Minimal delay for faster voting while ensuring widget stability
        setTimeout(() => {
          try {
            turnstile.execute(tournamentWidgetId, {
              callback: (token) => {
                pendingChallenges--;
                if (!token) {
                  return reject(new Error('Empty Turnstile token'));
                }
                
                // Validate token length (max 2048 characters)
                if (token.length > 2048) {
                  console.warn('Token too long:', token.length);
                  return reject(new Error('Invalid token format'));
                }
                
                resolve(token);
              },
              'error-callback': (error) => {
                pendingChallenges--;
                console.error('Turnstile execution error:', error);
                reject(new Error('Turnstile execution error: ' + error));
              }
            });
          } catch (e) {
            pendingChallenges--;
            console.error('Failed to execute Turnstile:', e);
            reject(new Error('Failed to execute Turnstile: ' + e.message));
          }
        }, 100); // Reduced from 250ms to 100ms for faster processing
      });
    }

    // Show simple next matchup button (like draftorpass.html)
    function showNextMatchupButton() {
      const container = document.getElementById('teamsContainer');
      
      // Check if button already exists
      let nextButton = container.querySelector('.next-button');
      if (nextButton) {
        nextButton.style.display = 'block';
        return;
      }
      
      // Create next matchup button (like draftorpass.html)
      nextButton = document.createElement("button");
      nextButton.textContent = "Next Matchup →";
      nextButton.className = "next-button";
      nextButton.onclick = async (e) => {
        
        // Show loading state
        const originalText = nextButton.textContent;
        nextButton.textContent = "Loading next matchup...";
        nextButton.disabled = true;
        
        try {
          await loadNextMatchup();
        } catch (error) {
          console.error('Error loading next matchup:', error);
          // Restore button if there's an error
          nextButton.textContent = originalText;
          nextButton.disabled = false;
        }
      };
      
      container.appendChild(nextButton);
    }
    
    // Function to load next matchup without page reload
    function loadNextMatchup() {
      const nextBtn = document.querySelector('.next-matchup-btn');
      if (nextBtn) {
        nextBtn.disabled = true;
        nextBtn.textContent = 'Loading...';
      }
      
      // Reload current matchup data
      fetch(`/api/tournament/current-matchup/${tournamentData.id}`)
        .then(response => response.json())
        .then(data => {
          const container = document.getElementById('teamsContainer');
          
          // Handle special cases first
          if (data.requiresLogin) {
            container.innerHTML = `
              <div class="no-matchup">
                <h3>Authentication Required</h3>
                <p>You must be <a href="/upload.html" style="color: #58a6ff; text-decoration: underline;">logged in</a> to vote in the tournament</p>
              </div>
            `;
            return;
          }
          
          if (data.allVoted) {
            container.innerHTML = `
              <div class="no-matchup">
                <h3>Round Complete</h3>
                <p>${data.message}</p>
              </div>
            `;
            return;
          }
          
          if (data.matchup) {
            // Display the new matchup
            displayMatchup(data.matchup);
          } else {
            container.innerHTML = `
              <div class="no-matchup">
                <h3>Tournament Status</h3>
                <p>${data.message || 'No active matchup at this time.'}</p>
              </div>
            `;
          }
        })
        .catch(error => {
          console.error('Error loading next matchup:', error);
          alert('Failed to load next matchup');
          if (nextBtn) {
            nextBtn.disabled = false;
            nextBtn.textContent = 'Retry';
          }
        });
    }
    
    // Extract matchup display logic into reusable function
    function displayMatchup(matchup) {
      const container = document.getElementById('teamsContainer');
      const team1VotesNeeded = (matchup.votes_needed || 4) - matchup.team1_votes;
      const team2VotesNeeded = (matchup.votes_needed || 4) - matchup.team2_votes;
      
      // Generate roster HTML for each team (reuse existing function)
      const generateRosterHTML = (roster) => {
        if (!roster || !roster.length) return '<div class="no-roster">No roster data available</div>';
        
        const counts = { QB: 0, RB: 0, WR: 0, TE: 0 };
        roster.forEach(p => { if (counts[p.position] !== undefined) counts[p.position]++; });
        
        const rosterConstructionHTML = `
          <div class="roster-construction">
            <div class="roster-counts">QB${counts.QB} | RB${counts.RB} | WR${counts.WR} | TE${counts.TE}</div>
          </div>
        `;
        
        const playerListHTML = roster.map(player => {
          const stackStar = player.stack ? `<span class="stack-star ${player.stack}">★</span>` : '';
          const pickHTML = (player.pick || player.pick === 0) ? `<span class="pick-num">#${player.pick}</span>` : '';
          const infoHTML = `<span class="player-info">${player.name}${player.team ? ` - ${player.team}` : ''}</span>`;
          
          return `
            <div class="player-row">
              <div class="player-bubble" style="border: 2px solid ${getBorderColor(player.position)}">
                ${pickHTML}${infoHTML}${stackStar}
              </div>
            </div>
          `;
        }).join('');
        
        return `${rosterConstructionHTML}<div class="player-list">${playerListHTML}</div>`;
      };
      
      const getBorderColor = (position) => {
        const colors = {
          QB: '#a855f7', RB: '#22c55e', WR: '#facc15', TE: '#3b82f6'
        };
        return colors[position] || '#999999';
      };

      container.innerHTML = `
        <div class="tournament-matchup">
          <div class="matchup-header">
            <h3>Round ${matchup.round_number} - Match ${matchup.bracket_position}</h3>
            <p class="matchup-subtitle">First to ${matchup.votes_needed || 4} votes wins!</p>
          </div>
          
          <div class="teams-grid">
            <div class="team-card tournament-team" data-team-id="${matchup.team1_id}">
              <div class="team-header">
                <h4>${matchup.team1_username}</h4>
                <div class="betting-info">
                  <span class="betting-odds">${matchup.team1_odds > 0 ? '+' : ''}${matchup.team1_odds}</span>
                  <span class="implied-probability">${matchup.team1_probability}% implied</span>
                </div>
              </div>
              
              ${generateRosterHTML(matchup.team1_roster)}
              
              <div class="vote-section">
                <button class="choose-button" onclick="castTournamentVote(${matchup.id}, '${matchup.team1_id}')" 
                        ${team1VotesNeeded <= 0 || team2VotesNeeded <= 0 ? 'disabled' : ''}>
                  <span>⬅️</span> Choose
                </button>
              </div>
            </div>            
            <div class="team-card tournament-team" data-team-id="${matchup.team2_id}">
              <div class="team-header">
                <h4>${matchup.team2_username}</h4>
                <div class="betting-info">
                  <span class="betting-odds">${matchup.team2_odds > 0 ? '+' : ''}${matchup.team2_odds}</span>
                  <span class="implied-probability">${matchup.team2_probability}% implied</span>
                </div>
              </div>
              
              ${generateRosterHTML(matchup.team2_roster)}
              
              <div class="vote-section">
                <button class="choose-button" onclick="castTournamentVote(${matchup.id}, '${matchup.team2_id}')"
                        ${team2VotesNeeded <= 0 || team1VotesNeeded <= 0 ? 'disabled' : ''}>
                  Choose <span>➡️</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function setupTournamentTabs() {
      const tabs = document.querySelectorAll('.tournament-tab');
      const tabContents = document.querySelectorAll('.tournament-tab-content');
      
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Remove active class from all tabs and contents
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          document.getElementById(targetTab + 'Tab').classList.add('active');
        });
      });
    }

    // Load tournament nominations count
    async function loadNominationsCount() {
      try {
        // Stop polling if tournament view is shown or tournament is not in setup status
        if (tournamentViewShown || (tournamentData && tournamentData.status !== 'setup')) {
          if (nominationsCountInterval) {
            clearInterval(nominationsCountInterval);
            nominationsCountInterval = null;
            console.log('Stopped nominations count polling - tournament view shown or not in setup');
          }
          return;
        }
        
        const response = await fetch(`/api/tournament/nominations-count/${tournamentData?.source_contest}`);
        const data = await response.json();
        
        if (response.ok) {
          const countElement = document.getElementById('teamsCount');
          if (countElement) {
            countElement.textContent = data.count;
            
            // Add visual feedback based on how full the tournament is
            const percentage = (data.count / data.max) * 100;
            const counterDisplay = countElement.parentElement;
            
            if (percentage >= 90) {
              counterDisplay.className = 'counter-display almost-full';
            } else if (percentage >= 75) {
              counterDisplay.className = 'counter-display getting-full';
            } else {
              counterDisplay.className = 'counter-display';
            }
          }
        } else {
          console.error('Error loading nominations count:', data.error);
        }
      } catch (error) {
        console.error('Error loading nominations count:', error);
      }
    }

    // Update countdown immediately and then every second
    updateCountdown();
    countdownInterval = setInterval(updateCountdown, 1000);
    
    // Update nominations count every 30 seconds (will stop automatically when tournament view shows)
    nominationsCountInterval = setInterval(loadNominationsCount, 30000);

    // Check if tournament should be active on page load
    document.addEventListener('DOMContentLoaded', async function() {
      // Load tournament info first
      await loadCurrentTournament();
      
      // Check if tournament should be active based on status or time
      // Only show tournament view if it hasn't been shown already
      if (tournamentData && !tournamentViewShown) {
        if (tournamentData.status === 'active' && !FORCE_COUNTDOWN_MODE) {
          // Tournament is active in database - show tournament view
          showTournamentView();
        } else if (tournamentStart) {
          const now = new Date();
          const timeDiff = tournamentStart - now;
          
          if (timeDiff <= 0 && !FORCE_COUNTDOWN_MODE) {
            // Tournament should be live based on time
            showTournamentView();
          }
        }
      }
      
      // Load nominations count immediately
      loadNominationsCount();
      
      // Refresh auth state if available
      if (typeof refreshAuth === 'function') {
        refreshAuth().then(() => {
          console.log('Auth refreshed for tournament');
        });
      }


    });

    // Fallback: ensure mobile menu works on this page even if global init didn't run
    document.addEventListener('headerLoaded', () => {
      const toggle = document.getElementById('mobileMenuToggle');
      const mobileNav = document.getElementById('mobileNav');
      if (!toggle || !mobileNav) return;
      if (toggle.dataset.bound === '1') return; // avoid double-binding
      toggle.dataset.bound = '1';

      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        mobileNav.classList.toggle('active');
        toggle.classList.toggle('active');
      });

      document.addEventListener('click', (e) => {
        if (!toggle.contains(e.target) && !mobileNav.contains(e.target)) {
          mobileNav.classList.remove('active');
          toggle.classList.remove('active');
        }
      });
    });

    // Mobile notifications (fallback implementation for this page) – match index.html behavior
    function showMobileNotifications() {
      let overlay = document.getElementById('mobileNotificationOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'mobileNotificationOverlay';
        overlay.className = 'mobile-notification-overlay';
        overlay.innerHTML = `
          <div class="mobile-notification-content">
            <div class="mobile-notification-header">
              <h3>Notifications</h3>
              <div class="mobile-notification-actions">
                <button id="mobileMarkAllRead" class="mobile-mark-all-read-btn">Mark all read</button>
                <button id="closeMobileNotifications" class="mobile-close-notifications-btn">✖</button>
              </div>
            </div>
            <div id="mobileNotificationList" class="mobile-notification-list">
              <div class="loading">Loading notifications...</div>
            </div>
          </div>
        `;

        // Click outside to close
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            overlay.style.display = 'none';
            document.body.style.overflow = '';
          }
        });

        // Close button
        overlay.querySelector('#closeMobileNotifications').addEventListener('click', () => {
          overlay.style.display = 'none';
          document.body.style.overflow = '';
        });

        // Mark all as read
        overlay.querySelector('#mobileMarkAllRead').addEventListener('click', async () => {
          try {
            await fetch('/notifications/read-all', { method: 'POST' });
            if (typeof window.updateNotificationBadge === 'function') {
              window.updateNotificationBadge(0);
            }
            const list = document.getElementById('mobileNotificationList');
            loadMobileNotificationsInto(list);
            if (typeof window.updateNotificationCount === 'function') {
              setTimeout(window.updateNotificationCount, 400);
            }
          } catch (e) {
            console.error('Failed to mark all read:', e);
          }
        });

        document.body.appendChild(overlay);
      }

      // Show overlay aligned to top per CSS
      overlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';

      // Load notifications into list
      const list = document.getElementById('mobileNotificationList');
      if (list) loadMobileNotificationsInto(list);
    }

    async function loadMobileNotificationsInto(container) {
      try {
        const res = await fetch('/notifications');
        if (!res.ok) throw new Error('Failed to load notifications');
        const data = await res.json();
        const notifications = data.notifications || [];
        if (notifications.length === 0) {
          container.innerHTML = '<div style="color:#8b949e;font-size:14px;padding:12px 0;">No notifications yet</div>';
          return;
        }
        container.innerHTML = notifications.map(n => {
          const time = new Date(n.created_at);
          const ago = formatTimeAgo(time);
          const isUnread = !n.is_read;
          return `
            <div class="mobile-notification-item" data-id="${n.id}" style="padding:10px;border-bottom:1px solid #30363d;${isUnread ? 'background:rgba(88,166,255,0.08);' : ''}">
              <div style="font-size:14px;color:#f0f6fc;line-height:1.4;">${n.message}</div>
              <div style="font-size:12px;color:#8b949e;margin-top:4px;">${ago}</div>
            </div>
          `;
        }).join('');
      } catch (e) {
        console.error('Notification load failed:', e);
        container.innerHTML = '<div style="color:#f85149;font-size:14px;padding:12px 0;">Failed to load notifications</div>';
      }
    }

    function formatTimeAgo(date) {
      const now = new Date();
      const diffMs = now - date;
      const s = Math.floor(diffMs / 1000);
      const m = Math.floor(s / 60);
      const h = Math.floor(m / 60);
      const d = Math.floor(h / 24);
      if (s < 60) return `${s}s ago`;
      if (m < 60) return `${m}m ago`;
      if (h < 24) return `${h}h ago`;
      return `${d}d ago`;
    }

    // Attach mobile notifications button when header is ready
    document.addEventListener('headerLoaded', () => {
      const btn = document.getElementById('mobileNotificationBtn');
      if (!btn || btn.dataset.bound === '1') return;
      btn.dataset.bound = '1';
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        try {
          const res = await fetch('/me');
          const auth = await res.json();
          if (auth && auth.user) {
            window.currentUserId = auth.user.id;
            showMobileNotifications();
          } else {
            alert('Please log in to view notifications');
          }
        } catch (err) {
          console.error('Auth check failed', err);
          alert('Please log in to view notifications');
        }
      });
    });

    // === MATCHUP POPUP FUNCTIONS ===
    
    // Show matchup popup with team details
    async function showMatchupPopup(matchupId) {
      try {
        // Show loading state
        showPopupLoading();
        
        // Fetch detailed matchup information
        const response = await fetch(`/api/tournament/matchup/${matchupId}`);
        const data = await response.json();
        
        if (!response.ok) {
          throw new Error(data.error || 'Failed to load matchup details');
        }
        
        if (data.matchup) {
          displayMatchupPopup(data.matchup);
        } else {
          throw new Error('No matchup data received');
        }
      } catch (error) {
        console.error('Error loading matchup popup:', error);
        showPopupError('Failed to load matchup details');
      }
    }

    // Display the matchup popup
    function displayMatchupPopup(matchup) {
      const modal = getOrCreateModal();
      
      const team1VotesNeeded = (matchup.votes_needed || 4) - (matchup.team1_votes || 0);
      const team2VotesNeeded = (matchup.votes_needed || 4) - (matchup.team2_votes || 0);
      const roundName = getRoundName(matchup.round_number, 8); // Assuming 8 total rounds
      
      const modalContent = `
        <div class="modal-body">
          <div class="teams-comparison">
            <div class="team-column">
              <div class="team-header ${matchup.winner_id ? (matchup.winner_id === matchup.team1_id ? 'winner' : 'loser') : ''}">
                <h3>${matchup.team1_username || 'TBD'}</h3>
                <div class="vote-info">
                  <span class="votes">Votes: ${matchup.team1_votes || 0}</span>
                </div>
              </div>
              ${generatePopupRoster(matchup.team1_roster)}
            </div>
            
            <div class="team-column">
              <div class="team-header ${matchup.winner_id ? (matchup.winner_id === matchup.team2_id ? 'winner' : 'loser') : ''}">
                <h3>${matchup.team2_username || 'TBD'}</h3>
                <div class="vote-info">
                  <span class="votes">Votes: ${matchup.team2_votes || 0}</span>
                </div>
              </div>
              ${generatePopupRoster(matchup.team2_roster)}
            </div>
          </div>
        </div>
      `;
      
      modal.innerHTML = modalContent;
      modal.style.display = 'flex';
      document.body.classList.add('modal-open');
    }

    // Generate roster HTML for popup
    function generatePopupRoster(roster) {
      if (!roster || !roster.length) {
        return '<div class="no-roster">No roster data available</div>';
      }
      
      // Count positions for roster construction
      const counts = { QB: 0, RB: 0, WR: 0, TE: 0 };
      roster.forEach(p => { if (counts[p.position] !== undefined) counts[p.position]++; });
      
      // Generate player list HTML
      const playerListHTML = roster.map(player => {
        const stackStar = player.stack ? `<span class="stack-star ${player.stack}">★</span>` : '';
        const pickHTML = (player.pick || player.pick === 0) ? `<span class="pick-num">#${player.pick}</span>` : '';
        const infoHTML = `<span class="player-info">${player.name}${player.team ? ` - ${player.team}` : ''}</span>`;
        
        return `
          <div class="player-row">
            <div class="player-bubble" style="border: 2px solid ${getPositionColor(player.position)}">
              ${pickHTML}${infoHTML}${stackStar}
            </div>
          </div>
        `;
      }).join('');
      
      return `
        <div class="player-list">
          ${playerListHTML}
        </div>
      `;

      (document.documentElement || document.body).appendChild(modal);
    }

    // Get position color (same as existing system)
    function getPositionColor(position) {
      const colors = {
        QB: '#a855f7', // Purple
        RB: '#22c55e', // Green
        WR: '#facc15', // Yellow
        TE: '#3b82f6'  // Blue
      };
      return colors[position] || '#999999';
    }

    // Modal utility functions
    function getOrCreateModal() {
      let modal = document.getElementById('matchupModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'matchupModal';
        modal.className = 'matchup-modal';
        // Attach to root to avoid body transforms affecting fixed positioning
        (document.documentElement || document.body).appendChild(modal);
        
        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeMatchupPopup();
          }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeMatchupPopup();
          }
        });
      }
      return modal;
    }

    function showPopupLoading() {
      const modal = getOrCreateModal();
      modal.innerHTML = `
        <div class="modal-loading">
          <div class="loading-spinner"></div>
          <p>Loading matchup details...</p>
        </div>
      `;
      modal.style.display = 'flex';
      // Ensure overlay centers content and sits above header
      modal.style.position = 'fixed';
      modal.style.inset = '0';
      modal.style.display = 'grid';
      modal.style.placeItems = 'center';
      modal.style.zIndex = '9999';
      document.body.classList.add('modal-open');
    }

    function showPopupError(message) {
      const modal = getOrCreateModal();
      modal.innerHTML = `
        <div class="modal-error">
          <h3>Error</h3>
          <p>${message}</p>
          <button onclick="closeMatchupPopup()">Close</button>
        </div>
      `;
      modal.style.display = 'flex';
      modal.style.position = 'fixed';
      modal.style.inset = '0';
      modal.style.display = 'grid';
      modal.style.placeItems = 'center';
      modal.style.zIndex = '9999';
      document.body.classList.add('modal-open');
    }

    function closeMatchupPopup() {
      const modal = document.getElementById('matchupModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.classList.remove('modal-open');
      }
    }

    // Clean up intervals when page unloads
    window.addEventListener('beforeunload', function() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }
      if (nominationsCountInterval) {
        clearInterval(nominationsCountInterval);
      }
    });
  </script>
  <footer class="legal-footer">
    <div class="footer-content">
      <div class="social-links">
        <a href="https://x.com/DraftrPass" target="_blank" rel="noopener noreferrer" title="Follow us on X">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://discord.gg/Y7hyQsfDQx" target="_blank" rel="noopener noreferrer" title="Join our Discord">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.566 18.566 0 0 0-5.487 0 12.36 12.36 0 0 0-.617-1.23A.077.077 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.07.07 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20.03 20.03 0 0 0 5.993 2.98.078.078 0 0 0 .084-.026 13.83 13.83 0 0 0 1.226-1.963.074.074 0 0 0-.041-.104 13.201 13.201 0 0 1-1.872-.878.075.075 0 0 1-.008-.125c.126-.093.252-.19.372-.287a.075.075 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.075.075 0 0 1 .079.009c.12.098.246.195.372.288a.075.075 0 0 1-.006.125c-.598.344-1.22.635-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.077.077 0 0 0 .084.028 19.963 19.963 0 0 0 6.002-2.981.076.076 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028zM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38z"/>
          </svg>
        </a>
      </div>
      <div class="legal-links">
        <a href="privacy.html" target="_blank">Privacy Policy</a>
        <a href="terms.html" target="_blank">Terms of Service</a>
      </div>
    </div>
  </footer>
</body>
</html>