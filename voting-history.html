<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voting History - Best Ball Voting</title>
  <link rel="stylesheet" href="style.css">
  <script defer src="header.js"></script>
  <script defer src="script.js"></script>
  <link rel="icon" type="image/x-icon" href="favicon_io/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon_io/favicon-16x16.png">

  <!-- Social share metadata -->
  <meta property="og:title" content="Voting History - Draft or Pass">
  <meta property="og:description" content="View team voting history and matchup results">
  <meta property="og:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://draftrpass.com/voting-history.html" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Voting History - Draft or Pass">
  <meta name="twitter:description" content="View team voting history and matchup results">
  <meta name="twitter:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta name="twitter:image:alt" content="Draft or Pass - Voting History page preview">

  <!-- Cloudflare Web Analytics -->
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "059f1f1236dc4f709c203129c35b24c2"}'></script>
  <!-- End Cloudflare Web Analytics -->

  <style>
    .voting-history-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Initially hide main content until auth check completes */
    .voting-history-container,
    .page-header h1 {
      opacity: 0;
      visibility: hidden;
    }

    /* Show content when auth is confirmed */
    .content-visible .voting-history-container,
    .content-visible .page-header h1 {
      opacity: 1;
      visibility: visible;
      transition: opacity 0.2s ease;
    }

    /* Ensure the team title header sits below the sticky site header */
    .page-header {
      margin-top: 5px; /* equal to .main-header height */
    }



    /* Page header styling */
    .page-header {
      text-align: center;
      padding: 20px;
      background: #0d1117;
    }

    .page-header .team-title {
      color: #c9d1d9;
      font-size: 24px;
      font-weight: 600;
      margin: 0;
    }

    .voting-history-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      text-align: center;
      position: relative;
    }

    .team-info {
      flex: 1;
      text-align: center;
    }

    .team-title {
      color: #c9d1d9;
      font-size: 24px;
      font-weight: 600;
      margin: 0;
    }

    .team-subtitle {
      color: #8b949e;
      font-size: 16px;
      margin: 5px 0 0 0;
    }

    .voting-history-content {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
    }

    .no-votes-message {
      text-align: center;
      padding: 40px 20px;
      color: #8b949e;
      font-size: 16px;
    }

    /* Enhanced table styles for the dedicated page */
    .votes-history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background: #161b22;
    }

    .votes-history-table th {
      font-weight: 600;
      color: #8b949e;
      background: #1c2128;
      padding: 12px;
      text-align: left;
      border-bottom: 2px solid #30363d;
      position: sticky;
      top: 0;
    }

    .votes-history-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #30363d;
      font-size: 14px;
      white-space: normal;
      word-wrap: break-word;
    }

    .votes-history-table tr:hover {
      background: #1c2128;
    }

    /* Column widths for better space utilization */
    .votes-history-table td:nth-child(1) { width: 90px; }  /* Result */
    .votes-history-table td:nth-child(2) { min-width: 140px; max-width: 220px; } /* Opponent */
    .votes-history-table td:nth-child(3) { width: 80px; text-align: center; }  /* Draftr Rating */
    .votes-history-table th:nth-child(3) { text-align: center; white-space: nowrap; min-width: 100px; }  /* Center header and keep on one line */
    .votes-history-table td:nth-child(4) { width: 70px; }  /* View */
    .votes-history-table td:nth-child(5) { min-width: 140px; max-width: 200px; } /* Voter */
    .votes-history-table td:nth-child(6) { width: 120px; } /* Date */

    /* Rating box styles - match vote results table styling from profile.html */
    .rating-box {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 12px;
      min-width: 24px;
      border: 1px solid;
      margin: 0;
      text-align: center;
    }

    .rating-box.tier-none {
      background-color: #374151;
      color: #9ca3af;
      border-color: #4b5563;
    }

    .rating-box.tier-low {
      background-color: #dc2626;
      color: #ffffff;
      border-color: #b91c1c;
    }

    .rating-box.tier-below {
      background-color: #ea580c;
      color: #ffffff;
      border-color: #c2410c;
    }

    .rating-box.tier-average {
      background-color: #ca8a04;
      color: #ffffff;
      border-color: #a16207;
    }

    .rating-box.tier-good {
      background-color: #16a34a;
      color: #ffffff;
      border-color: #15803d;
    }

    .rating-box.tier-elite {
      background-color: #2563eb;
      color: #ffffff;
      border-color: #1d4ed8;
    }

    .win-result {
      color: #238636;
      font-weight: 600;
    }

    .loss-result {
      color: #da3633;
      font-weight: 600;
    }

    .view-opponent-btn {
      background: #30363d;
      color: #c9d1d9;
      border: 1px solid #21262d;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    /* Only apply hover effect on devices that support true hovering (not touch) */
    @media (hover: hover) {
      .view-opponent-btn:hover {
        background: #58a6ff;
        color: #fff;
      }
    }

    /* Active state for touch devices */
    .view-opponent-btn:active {
      background: #58a6ff;
      color: #fff;
      transform: scale(0.95);
    }

    /* Ensure focus state doesn't stick */
    .view-opponent-btn:focus {
      outline: none;
      background: #30363d;
      color: #c9d1d9;
    }

    .view-team-btn {
      background: #238636;
      color: #fff;
      border: 1px solid #2ea043;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }

    /* Only apply hover effect on devices that support true hovering (not touch) */
    @media (hover: hover) {
      .view-team-btn:hover {
        background: #2ea043;
      }
    }

    /* Active state for touch devices */
    .view-team-btn:active {
      background: #2ea043;
      transform: scale(0.98);
    }

    /* Ensure focus state doesn't stick */
    .view-team-btn:focus {
      outline: none;
      background: #238636;
    }

    .loading-indicator {
      text-align: center;
      padding: 40px;
      color: #8b949e;
      font-size: 16px;
    }

    @media (max-width: 768px) {
      .voting-history-container {
        padding: 10px;
      }

      .voting-history-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
        gap: 15px;
      }

      .team-info {
        width: 100%;
      }

      .page-header .team-title {
        font-size: 20px;
        text-align: center;
      }

      .team-subtitle {
        text-align: center;
      }

      .votes-history-table {
        font-size: 12px;
      }

      .votes-history-table th,
      .votes-history-table td {
        padding: 8px 6px;
      }

      /* Adjust column widths for mobile */
      .votes-history-table td:nth-child(2) { min-width: 100px; max-width: 150px; } /* Opponent */
      .votes-history-table td:nth-child(3) { width: 60px; } /* Rating column mobile width */
      .votes-history-table td:nth-child(5) { min-width: 100px; max-width: 140px; } /* Voter */

      /* Make rating boxes slightly smaller on mobile - match profile.html */
      .rating-box {
        padding: 3px 6px;
        font-size: 10px;
        min-width: 20px;
        margin: 0;
      }

      /* Make view team button smaller on mobile */
      .view-team-btn {
        padding: 6px 12px;
        font-size: 12px;
        margin-top: 8px;
      }

      /* Make the table horizontally scrollable on mobile */
      .voting-history-content {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 20px; /* Add some padding for the scrollbar */
      }
    }

    /* Mobile notification button styling */
    .mobile-notification-btn {
      background: transparent;
      border: 1px solid #30363d;
      color: #f0f6fc;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      text-align: left;
      margin: 8px 0;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    /* Only apply hover effect on devices that support true hovering (not touch) */
    @media (hover: hover) {
      .mobile-notification-btn:hover {
        background: #21262d;
        border-color: #58a6ff;
      }
    }

    /* Active state for touch devices */
    .mobile-notification-btn:active {
      background: #21262d;
      border-color: #58a6ff;
      transform: scale(0.98);
    }

    /* Ensure focus state doesn't stick */
    .mobile-notification-btn:focus {
      outline: none;
      background: transparent;
      border-color: #30363d;
    }

    .mobile-notification-count {
      background: #f85149;
      color: white;
      border-radius: 12px;
      padding: 2px 8px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
    }



    /* Make the roster counts stick to top and list scroll */
  </style>
</head>
<body>

<main class="main-content">
  <!-- Page Title Section -->
  <div class="page-header">
    <h1 class="team-title" id="teamTitle">Loading...</h1>
  </div>



  <!-- Add after user-controls div -->
  <div id="loginRequiredMessage" class="login-required" style="display:none; text-align:center; padding:40px;">
    <h2>You need to be logged in to view this page</h2>
    <button id="goLoginBtn" class="start-voting-btn">Login →</button>
  </div>

  <div class="voting-history-container">
    <div class="voting-history-header">
      <div class="team-info">
        <p class="team-subtitle" id="teamSubtitle">Recent Voting History</p>
        <button id="viewTeamBtn" class="view-team-btn" style="margin-top: 10px;">View Team</button>
      </div>
    </div>

    <div class="voting-history-content">
      <div id="loadingIndicator" class="loading-indicator">
        Loading voting history...
      </div>
      <div id="votingHistoryTable" style="display: none;"></div>
    </div>
  </div>



  <script>
    // Get team ID from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const teamId = urlParams.get('teamId');

    if (!teamId) {
      document.getElementById('loadingIndicator').innerHTML = 'Error: No team ID provided';
      throw new Error('Team ID is required');
    }

    // Global variables for team modal functionality
    var currentUserId = window.currentUserId || null;

    // Mobile notification functions and variables
    let lastNotificationCount = 0;
    let notificationPollingInterval = null;

    // Notification badge and polling functions
    function updateNotificationBadge(count) {
      // Update desktop badge
      const desktopBadge = document.getElementById('notificationBadge');
      if (desktopBadge) {
        if (count > 0) {
          desktopBadge.textContent = `${count > 99 ? '99+' : count}`;
          desktopBadge.style.display = 'inline';
        } else {
          desktopBadge.style.display = 'none';
        }
      }

      // Update mobile badge
      const mobileBadge = document.getElementById('mobileNotificationBadge');
      if (mobileBadge) {
        if (count > 0) {
          mobileBadge.textContent = `${count > 99 ? '99+' : count}`;
          mobileBadge.style.display = 'inline';
        } else {
          mobileBadge.style.display = 'none';
        }
      }
    }

    async function updateNotificationCount() {
      try {
        const res = await fetch('/notifications/count');
        if (res.ok) {
          const data = await res.json();
          const count = data.count || 0;
          lastNotificationCount = count;
          updateNotificationBadge(count);
        } else {
          console.error('Failed to fetch notification count:', res.status, res.statusText);
        }
      } catch (e) {
        console.error('Failed to fetch notification count:', e);
      }
    }

    // Header navigation functionality
    function setupHeaderNavigation() {
      
      // Mobile menu toggle
      const mobileMenuToggle = document.getElementById('mobileMenuToggle');
      const mobileNav = document.getElementById('mobileNav');

      
      if (mobileMenuToggle && mobileNav) {
        mobileMenuToggle.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const isCurrentlyActive = mobileNav.classList.contains('active');
          
          if (isCurrentlyActive) {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          } else {
            mobileNav.classList.add('active');
            mobileMenuToggle.classList.add('active');
          }
        });
        
        // Close mobile menu when clicking on a link
        document.querySelectorAll('.mobile-nav-link').forEach(link => {
          link.addEventListener('click', () => {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          });
        });
        
        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!mobileMenuToggle.contains(e.target) && !mobileNav.contains(e.target)) {
            mobileNav.classList.remove('active');
            mobileMenuToggle.classList.remove('active');
          }
        });
      } else {
        console.error('Mobile menu elements not found');
      }

      // Desktop user menu toggle
      const userGear = document.getElementById('userGear');
      const userDropdown = document.getElementById('userDropdown');
      
      if (userGear && userDropdown) {
        userGear.addEventListener('click', (e) => {
          e.stopPropagation();
          userDropdown.style.display = userDropdown.style.display === 'block' ? 'none' : 'block';
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.user-menu')) {
            userDropdown.style.display = 'none';
          }
        });
      }
    }

    // Run setupHeaderNavigation immediately if header already injected, else wait for headerLoaded
    if (document.querySelector('.main-header')) {
      setupHeaderNavigation();
    } else {
      document.addEventListener('headerLoaded', setupHeaderNavigation);
    }

    // Setup header navigation and controls
    function setupHeaderControls() {
      // Desktop notification bell
      const notificationBell = document.getElementById('notificationBell');
      const notificationDropdown = document.getElementById('notificationDropdown');
      if (notificationBell && notificationDropdown) {
        notificationBell.addEventListener('click', (e) => {
          e.stopPropagation();
          const userMenu = document.querySelector('.user-menu');
          const isVisible = notificationDropdown.style.display !== 'none';
          
          // Toggle notification dropdown
          notificationDropdown.style.display = isVisible ? 'none' : 'block';
          // Hide user menu if open
          if (userMenu) userMenu.style.display = 'none';
          
          // Load notifications when opening
          if (!isVisible) {
            loadDesktopNotifications();
          }
        });
      }
      
      // Profile gear button
      const userGear = document.getElementById('userGear');
      if (userGear) {
        userGear.addEventListener('click', () => {
          window.location.href = '/profile.html';
        });
      }
      
      // Mark all read button
      const markAllReadBtn = document.getElementById('markAllRead');
      if (markAllReadBtn) {
        markAllReadBtn.addEventListener('click', markAllNotificationsAsRead);
      }
      
      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.user-controls')) {
          if (notificationDropdown) notificationDropdown.style.display = 'none';
          const userMenu = document.querySelector('.user-menu');
          if (userMenu) userMenu.style.display = 'none';
        }
      });
    }

    // Desktop notification functions
    async function loadDesktopNotifications() {
      const notificationList = document.getElementById('notificationList');
      if (!notificationList) return;

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        if (!res.ok) {
          notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];

        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = notifications.map(notification => {
          const timeAgo = formatTimeAgo(new Date(notification.created_at));
          let msgHtml = notification.message;
          
          // Enhance versus_vote messages with links
          if (notification.type === 'versus_vote' && notification.related_team_id) {
            msgHtml = msgHtml.replace('your team', `<a href="voting-history.html?teamId=${notification.related_team_id}" style="color:#58a6ff;text-decoration:none;">your team</a>`);
            
            if (notification.opponent_team_id) {
              const againstIndex = msgHtml.lastIndexOf('against ');
              if (againstIndex !== -1) {
                const beforeAgainst = msgHtml.substring(0, againstIndex + 8);
                const opponentName = msgHtml.substring(againstIndex + 8);
                if (opponentName.trim()) {
                  msgHtml = beforeAgainst + `<span class="desktop-opponent-link" data-team-id="${notification.opponent_team_id}" style="color:#58a6ff;cursor:pointer;text-decoration:none;">${opponentName}</span>`;
                }
              }
            }
          }
          
          return `
            <div class="notification-item ${notification.is_read ? 'read' : 'unread'}" data-notification-id="${notification.id}">
              <div class="notification-message">${msgHtml}</div>
              <div class="notification-time">${timeAgo}</div>
            </div>
          `;
        }).join('');

        // Attach opponent link handlers
        document.querySelectorAll('.desktop-opponent-link').forEach(link => {
          link.addEventListener('click', async (e) => {
            e.stopPropagation();
            const teamId = link.getAttribute('data-team-id');
            if (!teamId) return;
            try {
              const res = await fetch(`/team-meta/${teamId}`);
              const meta = await res.json();
              if (meta && meta.username) {
                window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
              } else {
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            } catch (err) {
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          });
        });

        // Mark notifications as read when clicked
        document.querySelectorAll('.notification-item.unread').forEach(item => {
          item.addEventListener('click', async () => {
            const notificationId = item.dataset.notificationId;
            if (notificationId) {
              try {
                await fetch('/notifications/read', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ notificationIds: [parseInt(notificationId)] })
                });
                item.classList.remove('unread');
                item.classList.add('read');
                await updateNotificationCount();
              } catch (e) {
                console.error('Failed to mark notification as read:', e);
              }
            }
          });
        });

      } catch (e) {
        console.error('Failed to load desktop notifications:', e);
        notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
      }
    }

    async function markAllNotificationsAsRead() {
      try {
        const res = await fetch('/notifications/read-all', {
          method: 'POST'
        });
        if (res.ok) {
          // Update badge immediately for visual feedback
          updateNotificationBadge(0);
          // Reload notifications list
          await loadDesktopNotifications();
          // Refresh count after delay
          setTimeout(async () => {
            await updateNotificationCount();
          }, 500);
        }
      } catch (e) {
        console.error('Failed to mark all notifications as read:', e);
      }
    }

    // Listen for auth state resolution from header.js
    document.addEventListener('authStateResolved', (event) => {
      const { isLoggedIn, user } = event.detail;
      
      // Setup header navigation regardless of auth status (mobile menu should always work)
      document.addEventListener('headerLoaded', setupHeaderNavigation);
      
      if (isLoggedIn) {
        currentUserId = user.id;
        const displayName = user.display_name || user.email || 'User';
        
        // Wait for header to load before accessing header elements
        document.addEventListener('headerLoaded', () => {
          // Update desktop user controls
          const userLabel = document.getElementById('userLabel');
          if (userLabel) userLabel.textContent = displayName;
          
          // Setup authenticated header controls
          setupHeaderControls();
          
          // Setup mobile notifications
          setupMobileNotifications();
        });
        
        
        // Start notification polling
        updateNotificationCount();
        startNotificationPolling();
        
        // After auth check, load voting history
        loadVotingHistory();
      } else {
        showLoginRequired();
      }
    });

    // Fallback: if auth state was already resolved before this listener was added
    if (document.body.classList.contains('content-visible')) {
      // Check if user is authenticated based on body class
      if (document.body.classList.contains('authenticated')) {
        // User is logged in, but we need to wait for the script to set up currentUserId
        setTimeout(() => {
          if (typeof currentUserId !== 'undefined' && currentUserId) {
            loadVotingHistory();
          } else {
            // Try to get user info from header elements
            const userLabel = document.getElementById('userLabel');
            if (userLabel && userLabel.textContent) {
              loadVotingHistory();
            } else {
              showLoginRequired();
            }
          }
        }, 100);
      } else {
        showLoginRequired();
      }
    }
    


    function showLoginRequired() {
      // Show content first by adding the content-visible class
      document.body.classList.add('content-visible');
      
      // Hide main content and header text
      document.querySelector('.voting-history-container').style.display = 'none';
      document.getElementById('teamTitle').style.display = 'none';
      
      // Show login required message
      const msgDiv = document.getElementById('loginRequiredMessage');
      msgDiv.style.display = 'block';
      
      // Attach click handler once
      const btn = document.getElementById('goLoginBtn');
      if (btn && !btn.dataset.bound) {
        btn.dataset.bound = '1';
        btn.addEventListener('click', () => {
          window.location.href = '/upload';
        });
      }
    }

    // Logout functionality
    function setupLogoutHandlers() {
      // Desktop logout
      const logoutBtn = document.getElementById('logoutBtn');
      if (logoutBtn) {
        logoutBtn.addEventListener('click', async () => {
          await fetch('/logout', { method: 'POST' });
          window.location.href = '/';
        });
      }
      
      // Mobile logout
      const mobileLogoutBtn = document.getElementById('mobileLogoutBtn');
      if (mobileLogoutBtn) {
        mobileLogoutBtn.addEventListener('click', async () => {
          await fetch('/logout', { method: 'POST' });
          window.location.href = '/';
        });
      }
    }
    
    // Call logout setup after page loads
    setupLogoutHandlers();

    // === Simple center-screen popup used by View buttons ===
    function showSimplePopup(content = "This is a popup") {
      // Remove any existing popup first
      const existing = document.querySelector('.simple-popup-overlay');
      if (existing) existing.remove();
    
      // Create overlay that always covers the viewport regardless of scrolling
      const overlay = document.createElement('div');
      overlay.className = 'simple-popup-overlay';
      Object.assign(overlay.style, {
        position: 'fixed',      // lock to viewport
        inset: '0',             // shorthand for top/right/bottom/left 0
        background: 'rgba(0,0,0,0.6)',
        display: 'grid',        // grid makes centering trivial
        placeItems: 'center',   // center both horizontally & vertically
        zIndex: 9999            // very high to sit above other fixed elements
      });
    
      // Create popup box
      const box = document.createElement('div');
      Object.assign(box.style, {
        background: '#0d1117',
        color: '#f0f6fc',
        padding: '24px 32px',
        borderRadius: '8px',
        fontSize: '18px',
        maxWidth: window.innerWidth <= 768 ? '98vw' : '95vw',
        width: window.innerWidth <= 768 ? 'auto' : '600px',
        textAlign: 'center',
        boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
        fontFamily: "'Söhne', 'Inter', sans-serif"
      });
    
      // Inject content
      if (content instanceof Node) {
        // Add CSS to make player-bubble fill full width in popup
        const style = document.createElement('style');
        style.textContent = `
          .simple-popup-overlay .player-list {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
          }
          .simple-popup-overlay .player-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 0 16px;
          }
          .simple-popup-overlay .player-bubble {
            width: 100% !important;
            max-width: none !important;
            margin: 0 48px;
          }
          @media (max-width: 768px) {
            .simple-popup-overlay .player-row {
              padding: 0 12px;
            }
            .simple-popup-overlay .player-bubble {
              width: 100% !important;
              margin: 0 6px;
            }
          }
        `;
        document.head.appendChild(style);
        box.appendChild(content);
      } else if (content) {
        box.textContent = String(content);
      }
    
      // Prevent click propagation inside the box
      box.addEventListener('click', (e) => e.stopPropagation());
    
      // Close popup when overlay area outside box is clicked
      overlay.addEventListener('click', () => overlay.remove());
    
      overlay.appendChild(box);
      // Append to <html> instead of <body> to avoid transforms on body affecting fixed positioning
      (document.documentElement || document.body).appendChild(overlay);
    }

    // === Team card builder ===
    function buildTeamCard(teamId, players) {
      const card = document.createElement("div");
      card.className = "team-card";
    
      // Get tournament name for this team to handle special position color rules
      const tournamentName = teamData?.tournament || "";
    
      // --- Roster construction counts at the top ---
      const counts = { QB: 0, RB: 0, WR: 0, TE: 0 };
      players.forEach(p => { if (counts[p.position] !== undefined) counts[p.position]++; });
      const rosterConstruction = document.createElement("div");
      rosterConstruction.className = "roster-construction";
      rosterConstruction.innerHTML = `<div class="roster-counts">QB${counts.QB} | RB${counts.RB} | WR${counts.WR} | TE${counts.TE}</div>`;
      card.appendChild(rosterConstruction);
    
      // --- Player list (vertical) ---
      const list = document.createElement("div");
      list.className = "player-list";
    
      // Sort players first by position (QB, RB, WR, TE) then by pick number
      const positionOrder = { QB: 0, RB: 1, WR: 2, TE: 3 };
      const playersSorted = [...players].sort((a, b) => {
        if (positionOrder[a.position] !== positionOrder[b.position]) {
          return positionOrder[a.position] - positionOrder[b.position];
        }
        return (a.pick || 0) - (b.pick || 0);
      });
    
      ["QB", "RB", "WR", "TE"].forEach(pos => {
        playersSorted.filter(p => p.position === pos).forEach(pl => {
          const row = document.createElement("div");
          row.className = "player-row";
    
          const bubble = document.createElement("div");
          bubble.className = "player-bubble";
          const stackStar = pl.stack ? 
            `<span class="stack-star ${pl.stack}">★</span>` : '';
          // Build bubble content with pick number left-aligned and player info centered
          const pickHTML = (pl.pick || pl.pick === 0) ? `<span class="pick-num">#${pl.pick}</span>` : '';
          const infoHTML = `<span class="player-info">${pl.name}${pl.team ? ` - ${pl.team}` : ''}</span>`;
          const starHTML = stackStar; // star after info for positioning via CSS
          bubble.innerHTML = `${pickHTML}${infoHTML}${starHTML}`;
          bubble.style.border = `2px solid ${getBorderColor(pl.position, tournamentName)}`;
    
          row.appendChild(bubble);
          list.appendChild(row);
        });
      });
    
      card.appendChild(list);
      return card;
    }

    // === Helper for border colors ===
    function getBorderColor(position, tournamentName = "") {
      // Special case: In "Rookies and Sophomores" tournament, treat TE same as WR (yellow)
      if (tournamentName === "Rookies and Sophomores" && position === "TE") {
        return "#facc15"; // WR color (yellow)
      }
      
      switch (position) {
        case "QB": return "#a855f7";
        case "RB": return "#22c55e";
        case "WR": return "#facc15";
        case "TE": return "#3b82f6";
        default: return "#999";
      }
    }

    // Helper to determine rating tier and return appropriate CSS class
    function getRatingTierClass(rating) {
      if (!rating || rating === 0) return 'tier-none';
      if (rating < 60) return 'tier-low';      // 0-59: Red
      if (rating < 70) return 'tier-below';    // 60-69: Orange  
      if (rating < 80) return 'tier-average';  // 70-79: Yellow
      if (rating < 90) return 'tier-good';     // 80-89: Green
      return 'tier-elite';                     // 90-99: Blue
    }

    // Helper to format rating in a colored box
    function formatRatingBox(rating) {
      if (!rating || rating === 0) return '<span class="rating-box tier-none">-</span>';
      const tierClass = getRatingTierClass(rating);
      return `<span class="rating-box ${tierClass}">${Math.round(rating)}</span>`;
    }

    // Global team data for tournament information
    let teamData = null;

    // Load voting history
    async function loadVotingHistory() {
      try {
        // First, get team information
        const teamResponse = await fetch(`/team-meta/${teamId}`);
        teamData = await teamResponse.json();
        
        document.getElementById('teamTitle').textContent = 
          `${teamData.username || 'Anonymous'} - ${teamData.tournament || 'Unknown Contest'}`;

        // Then get voting history
        const votesResponse = await fetch(`/team-votes/${teamId}`);
        const votesData = await votesResponse.json();

        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('votingHistoryTable').style.display = 'block';

        if (!votesData.votes.length) {
          document.getElementById('votingHistoryTable').innerHTML = 
            '<div class="no-votes-message">No voting history yet for this team.</div>';
          return;
        }

        // Build the table
        let tableHtml = `
          <table class="votes-history-table">
            <thead>
              <tr>
                <th>Result</th>
                <th>Opponent</th>
                <th>Draftr Rating</th>
                <th>View</th>
                <th>Voter</th>
                <th>Date</th>
              </tr>
            </thead>
            <tbody>
        `;

        votesData.votes.forEach(vote => {
          const date = new Date(vote.created_at).toLocaleDateString();
          const result = vote.result === 'win' ? '✅ Win' : '❌ Loss';
          const resultClass = vote.result === 'win' ? 'win-result' : 'loss-result';
          const ratingBox = formatRatingBox(vote.opponent_madden);
          
          tableHtml += `
            <tr>
              <td class="${resultClass}">${result}</td>
              <td>${vote.opponent_username || 'Anonymous'}</td>
              <td>${ratingBox}</td>
              <td><button class="view-opponent-btn" data-id="${vote.opponent_id}">View</button></td>
              <td>${vote.voter_name || 'Anonymous'}</td>
              <td>${date}</td>
            </tr>
          `;
        });

        tableHtml += '</tbody></table>';
        document.getElementById('votingHistoryTable').innerHTML = tableHtml;

        // Add event listeners for view opponent buttons
        const opponentBtns = document.querySelectorAll('.view-opponent-btn');
        
        opponentBtns.forEach((btn, index) => {
          btn.addEventListener('click', async (e) => {

            
            if (typeof showSimplePopup === 'function') {
              showSimplePopup('Loading...');
            } else {
              console.error('showSimplePopup not available!');
            }
            
            const opponentId = btn.getAttribute('data-id');
            if (!opponentId) return;
            
            try {
              const res = await fetch(`/team/${opponentId}`);
              if (!res.ok) throw new Error('Failed');
              const players = await res.json();
              const card = buildTeamCard(opponentId, players);
              const list = card.querySelector('.player-list');
              if (list) showSimplePopup(list.cloneNode(true));
            } catch(err){ console.error('Popup error', err); }
          });
        });

        // Add event listener for the main team view button (current team)
        const vtBtn = document.getElementById('viewTeamBtn');
        if (vtBtn) {
          vtBtn.addEventListener('click', async () => {
            
            if (typeof showSimplePopup === 'function') {
              showSimplePopup('Loading...');
            } else {
              console.error('showSimplePopup not available!');
            }
            
            try {
              const res = await fetch(`/team/${teamId}`);
              if (!res.ok) throw new Error('Failed');
              const players = await res.json();
              const card = buildTeamCard(teamId, players);
              const list = card.querySelector('.player-list');
              if (list) showSimplePopup(list.cloneNode(true));
            } catch(err){ console.error('Popup error', err); }
          });
        }

      } catch (error) {
        console.error('Failed to load voting history:', error);
        document.getElementById('loadingIndicator').innerHTML = 
          'Error loading voting history. Please try again.';
      }
    }



    // ---- Mobile Notification Functions ----
    
    function setupMobileNotifications() {
      // Update notification count and badge
      updateNotificationCount();
      

      
      // Setup mobile notification button click handler
      const mobileNotificationBtn = document.getElementById('mobileNotificationBtn');
      if (mobileNotificationBtn) {
        mobileNotificationBtn.addEventListener('click', () => {
          showMobileNotifications();
        });
      }
      
      // Start notification polling
      startNotificationPolling();
    }

    // Ensure mobile notifications handler is attached whether header arrived early or later
    if (document.querySelector('.main-header')) {
      setupMobileNotifications();
    } else {

      document.addEventListener('headerLoaded', () => {
        setupMobileNotifications();
      }, { once: true });
    }

    function showMobileNotifications() {
      // Check if user is logged in first
      if (!currentUserId) {
        console.warn('User not logged in, cannot show notifications');
        alert('Please log in to view notifications');
        return;
      }

      // Create mobile notification overlay if it doesn't exist
      let overlay = document.getElementById('mobileNotificationOverlay');
      if (!overlay) {
        overlay = createMobileNotificationOverlay();
        document.body.appendChild(overlay);
      }
      
      // Show the overlay
      overlay.style.display = 'flex';
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      
      // Load notifications
      loadMobileNotifications();
    }

    function hideMobileNotifications() {
      const overlay = document.getElementById('mobileNotificationOverlay');
      if (overlay) {
        overlay.style.display = 'none';
        document.body.style.overflow = ''; // Restore scrolling
      }
    }

    function createMobileNotificationOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'mobileNotificationOverlay';
      overlay.className = 'mobile-notification-overlay';
      
      overlay.innerHTML = `
        <div class="mobile-notification-content">
          <div class="mobile-notification-header">
            <h3>Notifications</h3>
            <div class="mobile-notification-actions">
              <button id="mobileMarkAllRead" class="mobile-mark-all-read-btn">Mark all read</button>
              <button id="closeMobileNotifications" class="mobile-close-notifications-btn">✖</button>
            </div>
          </div>
          <div id="mobileNotificationList" class="mobile-notification-list">
            <div class="loading">Loading notifications...</div>
          </div>
        </div>
      `;

      // Add event listeners
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          hideMobileNotifications();
        }
      });

      overlay.querySelector('#closeMobileNotifications').addEventListener('click', hideMobileNotifications);
      overlay.querySelector('#mobileMarkAllRead').addEventListener('click', markAllNotificationsAsReadMobile);
      
      return overlay;
    }

    async function loadMobileNotifications() {
      const notificationList = document.getElementById('mobileNotificationList');
      if (!notificationList) return;

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        
        if (!res.ok) {
          if (res.status === 401) {
            notificationList.innerHTML = '<div class="no-notifications">Please log in to view notifications</div>';
          } else {
            notificationList.innerHTML = `<div class="no-notifications">Failed to load notifications (${res.status})</div>`;
          }
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];
        
        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = '';
        notifications.forEach((notification, index) => {
          try {
            const item = createMobileNotificationItem(notification);
            notificationList.appendChild(item);
          } catch (itemError) {
            console.error(`Error creating mobile notification item ${index}:`, itemError);
          }
        });
      } catch (e) {
        console.error('Failed to load mobile notifications:', e);
        notificationList.innerHTML = `<div class="no-notifications">Network error: ${e.message}</div>`;
      }
    }

    function createMobileNotificationItem(notification) {
      const item = document.createElement('div');
      item.className = `mobile-notification-item ${notification.is_read ? '' : 'unread'}`;
      item.dataset.notificationId = notification.id;

      const timeAgo = formatTimeAgo(new Date(notification.created_at));
      
      // Create enhanced notification message with links for versus votes
      let messageHTML = notification.message;
      
      if (notification.type === 'versus_vote' && notification.related_team_id) {
        // First, create the team link
        const teamLink = `<a href="voting-history.html?teamId=${notification.related_team_id}" style="color: #58a6ff; text-decoration: none;">your team</a>`;
        messageHTML = messageHTML.replace('your team', teamLink);
        
        // If we have opponent info, find and replace just the opponent name at the very end
        if (notification.opponent_team_id) {
          const againstIndex = messageHTML.lastIndexOf('against ');
          if (againstIndex !== -1) {
            const beforeAgainst = messageHTML.substring(0, againstIndex + 8);
            const opponentName = messageHTML.substring(againstIndex + 8);
            
            if (opponentName.trim()) {
              const opponentLink = `<span class="mobile-opponent-link" data-team-id="${notification.opponent_team_id}" style="color: #58a6ff; cursor: pointer; text-decoration: underline;">${opponentName}</span>`;
              messageHTML = beforeAgainst + opponentLink;
            }
          }
        }
      }
      
      item.innerHTML = `
        <div class="mobile-notification-message">${messageHTML}</div>
        <div class="mobile-notification-time">${timeAgo}</div>
      `;

      // Add click handlers for opponent links
      const opponentLinks = item.querySelectorAll('.mobile-opponent-link');
      opponentLinks.forEach(link => {
        link.addEventListener('click', async (e) => {
          e.stopPropagation();
          const teamId = link.getAttribute('data-team-id');
          if (teamId) {
            try {
              // Fetch team metadata to get the opponent's username
              const response = await fetch(`/team-meta/${teamId}`);
              if (response.ok) {
                const meta = await response.json();
                if (meta.username) {
                  // Navigate to the opponent's profile page
                  window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
                } else {
                  // Fallback: navigate to voting history page if no username
                  window.location.href = `voting-history.html?teamId=${teamId}`;
                }
              } else {
                // Fallback: navigate to voting history page on API error
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            } catch (error) {
              console.error('Failed to fetch opponent info:', error);
              // Fallback: navigate to voting history page
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          }
        });
      });

      // Mark as read when clicked (but not when clicking links)
      item.addEventListener('click', async (e) => {
        if (e.target.tagName === 'A' || e.target.classList.contains('mobile-opponent-link')) {
          return;
        }
        
        if (!notification.is_read) {
          await markNotificationAsRead(notification.id);
          item.classList.remove('unread');
          await updateNotificationCount();
        }
      });

      return item;
    }

    async function markNotificationAsRead(notificationId) {
      try {
        await fetch('/notifications/read', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ notificationIds: [notificationId] })
        });
      } catch (e) {
        console.error('Failed to mark notification as read:', e);
      }
    }

    async function markAllNotificationsAsReadMobile() {
      try {
        const res = await fetch('/notifications/read-all', {
          method: 'POST'
        });
        if (res.ok) {
          // Immediately update the badge to 0 for instant feedback
          updateNotificationBadge(0);
          
          // Reload the notification list
          await loadMobileNotifications();
          
          // Wait a moment for database to update, then refresh count
          setTimeout(async () => {
            await updateNotificationCount();
          }, 500);
        } else {
          console.error('Failed to mark all mobile notifications as read:', res.status, res.statusText);
        }
      } catch (e) {
        console.error('Failed to mark all mobile notifications as read:', e);
      }
    }

    function formatTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);

      if (minutes < 1) return 'Just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;
      return date.toLocaleDateString();
    }

    function startNotificationPolling() {
      if (notificationPollingInterval) {
        clearInterval(notificationPollingInterval);
      }

      if (!currentUserId) return;

      notificationPollingInterval = setInterval(async () => {
        if (currentUserId) {
          await updateNotificationCount();
        } else {
          stopNotificationPolling();
        }
      }, 30000);
    }

    function stopNotificationPolling() {
      if (notificationPollingInterval) {
        clearInterval(notificationPollingInterval);
        notificationPollingInterval = null;
      }
    }
  </script>
  <script src="analytics.js"></script>
</main>

  <footer class="legal-footer">
    <div class="footer-content">
      <div class="social-links">
        <a href="https://x.com/DraftrPass" target="_blank" rel="noopener noreferrer" title="Follow us on X">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://discord.gg/Y7hyQsfDQx" target="_blank" rel="noopener noreferrer" title="Join our Discord">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.566 18.566 0 0 0-5.487 0 12.36 12.36 0 0 0-.617-1.23A.077.077 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.07.07 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20.03 20.03 0 0 0 5.993 2.98.078.078 0 0 0 .084-.026 13.83 13.83 0 0 0 1.226-1.963.074.074 0 0 0-.041-.104 13.201 13.201 0 0 1-1.872-.878.075.075 0 0 1-.008-.125c.126-.093.252-.19.372-.287a.075.075 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.075.075 0 0 1 .079.009c.12.098.246.195.372.288a.075.075 0 0 1-.006.125c-.598.344-1.22.635-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.077.077 0 0 0 .084.028 19.963 19.963 0 0 0 6.002-2.981.076.076 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028zM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38z"/>
          </svg>
        </a>
      </div>
      <div class="legal-links">
        <a href="privacy.html" target="_blank">Privacy Policy</a>
        <a href="terms.html" target="_blank">Terms of Service</a>
      </div>
    </div>
  </footer>
</body>
</html> 