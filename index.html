<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Draft or Pass</title>
  <link rel="stylesheet" href="style.css" />
  <script defer src="header.js"></script>
  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="/favicon_io/site.webmanifest">
  <link rel="shortcut icon" href="/favicon_io/favicon.ico">

  <!-- Social share metadata -->
  <meta property="og:title" content="Draft or Pass - Best Ball Voting">
  <meta property="og:description" content="Vote on best ball drafts!">
  <meta property="og:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://draftrpass.com/" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Draft or Pass - Best Ball Voting">
  <meta name="twitter:description" content="Vote on best ball drafts!">
  <meta name="twitter:image" content="https://draftrpass.com/social_share_img.png?v=2">
  <meta name="twitter:image:alt" content="Draft or Pass - Best Ball Voting app preview">
  
  <!-- DNS prefetch for external resources -->
  <link rel="dns-prefetch" href="//challenges.cloudflare.com">
  <link rel="dns-prefetch" href="//static.cloudflareinsights.com">
  
  <!-- Preload critical resources -->
  <link rel="preload" href="/api/widgets/top-drafters" as="fetch" crossorigin>
  <link rel="preload" href="/api/widgets/top-teams" as="fetch" crossorigin>
  <link rel="preload" href="/api/widgets/recent-votes" as="fetch" crossorigin>
  <link rel="preload" href="style.css" as="style">
  <link rel="preload" href="script.js" as="script">
  
  <!-- Prefetch likely next page -->
  <link rel="prefetch" href="/draftorpass">
  
  <!-- Cloudflare Web Analytics -->
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "059f1f1236dc4f709c203129c35b24c2"}'></script>
  <!-- End Cloudflare Web Analytics -->

  <!-- Cloudflare Turnstile for bot protection -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit" async defer></script>
  <script>
    window.TURNSTILE_SITE_KEY='1x00000000000000000000AA'; // demo key
  </script>
</head>
<body>
  <!-- Special Banner -->
  <div class="special-banner">
    Today's Special Teams: Elite QB - <a href="/draftorpass" style="color: #ffffff; text-decoration: underline; font-weight: 700;">Vote Now</a>
  </div>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="hero-content">
      <h1 class="hero-title">The Ultimate Fantasy Football Draft Judge</h1>
      <p class="hero-subtitle">Think you're a good drafter? Upload your teams and see if the community agrees!</p>
      <button id="startVotingBtn" class="hero-cta-btn">Start Voting Now</button>
    </div>
  </section>

  <!-- Widgets Grid -->
  <section class="widgets-grid">
    <!-- Top 10 Drafters Widget -->
    <div class="widget top-drafters" data-widget="top-drafters">
      <h2>üèÜ Top 10 Overall Drafters</h2>
      <div class="widget-content" id="topDraftersContent">
        <div class="skeleton-loader">
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
        </div>
      </div>
    </div>

    <!-- Top 10 Teams Widget -->
    <div class="widget top-teams" data-widget="top-teams">
      <h2>üåü Top 10 Overall Teams</h2>
      <div class="widget-content" id="topTeamsContent">
        <div class="skeleton-loader">
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
        </div>
      </div>
    </div>

    <!-- Recent Votes Widget -->
    <div class="widget recent-votes" data-widget="recent-votes">
      <h2>üìä Recent Votes <span id="recentVotesIndicator" class="update-indicator" style="visibility:hidden;">üîÑ</span></h2>
      <div class="widget-content" id="recentVotesContent">
        <div class="skeleton-loader">
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
          <div class="skeleton-row"></div>
        </div>
      </div>
    </div>

    <!-- Upload Promotion Widget -->
    <div class="widget upload-promo">
      <div class="upload-promo-content">
        <h2>Ready to Play?</h2>
        <p>Send your teams into the gauntlet and see how they stack up.</p>
        <a href="/upload" class="upload-promo-btn">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 12.5l-3.5-3.5h2.5v-4h2v4h2.5L8 12.5z M3 14v-2h10v2H3z"/>
          </svg>
          Upload Teams
        </a>
      </div>
    </div>

    <!-- Draft or Pass Widget -->
    <div class="widget draft-or-pass" data-widget="draft-or-pass">
      <h2>Vote Now - Which Team is Better? <span id="draftOrPassIndicator" class="update-indicator" style="visibility:hidden;">üîÑ</span></h2>
      <div class="widget-content" id="draftOrPassContent">
        <div id="teamsContainer" class="teams-container">
          <div class="skeleton-loader">
            <div class="skeleton-team-card"></div>
            <div class="skeleton-team-card"></div>
          </div>
        </div>
        <a href="/draftorpass" class="skip-matchup">Skip This Matchup</a>
      </div>
    </div>
  </section>

  <!-- Hidden Turnstile container -->
  <div id="cf-container" style="display:none;"></div>

  <script src="analytics.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script defer src="script.js"></script>
  <script>
    // Load Top 10 Drafters widget
    async function loadTopDrafters() {
      const container = document.getElementById('topDraftersContent');
      if (!container) return;
      
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
        
        const res = await fetch('/api/widgets/top-drafters', {
          signal: controller.signal,
          headers: {
            'Cache-Control': 'max-age=300' // Cache for 5 minutes
          }
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch top drafters`);
        const data = await res.json();
        
        if (!data || !data.length) {
          container.innerHTML = '<div class="error-message">No data available</div>';
          return;
        }

        // Helper to determine rating tier and return appropriate CSS class
        function getRatingTierClass(rating) {
          if (!rating || rating === 0) return 'tier-none';
          if (rating < 60) return 'tier-low';      // 0-59: Red
          if (rating < 70) return 'tier-below';    // 60-69: Orange  
          if (rating < 80) return 'tier-average';  // 70-79: Yellow
          if (rating < 90) return 'tier-good';     // 80-89: Green
          return 'tier-elite';                     // 90-99: Blue
        }

        // Helper to format rating in a colored box
        function formatRatingBox(rating) {
          if (!rating || rating === 0) return '<span class="rating-box tier-none">-</span>';
          const tierClass = getRatingTierClass(rating);
          return `<span class="rating-box ${tierClass}">${Math.round(rating)}</span>`;
        }

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        
        data.forEach((drafter, i) => {
          const row = document.createElement('div');
          row.className = 'drafter-row';
          row.innerHTML = `
            <div class="drafter-rank">${i + 1}</div>
            <div class="drafter-name"><a href="profile.html?user=${encodeURIComponent(drafter.username)}" style="color:inherit; text-decoration:none;">${drafter.username}</a></div>
            ${formatRatingBox(drafter.median_rating)}
          `;
          fragment.appendChild(row);
        });
        
        const link = document.createElement('a');
        link.href = '/leaderboard';
        link.className = 'see-full-link';
        link.textContent = 'View Full Leaderboard';
        fragment.appendChild(link);
        
        container.innerHTML = '';
        container.appendChild(fragment);
        
      } catch (e) {
        console.error('Error loading top drafters:', e);
        if (e.name === 'AbortError') {
          container.innerHTML = '<div class="error-message">Request timed out</div>';
        } else {
          container.innerHTML = '<div class="error-message">Failed to load data</div>';
        }
      }
    }

    // Load Top 10 Teams widget
    async function loadTopTeams() {
      const container = document.getElementById('topTeamsContent');
      try {
        const res = await fetch('/api/widgets/top-teams');
        if (!res.ok) throw new Error('Failed to fetch top teams');
        const data = await res.json();
        
        if (!data || !data.length) {
          container.innerHTML = '<div class="error-message">No data available</div>';
          return;
        }

        // Helper to determine rating tier and return appropriate CSS class
        function getRatingTierClass(rating) {
          if (!rating || rating === 0) return 'tier-none';
          if (rating < 60) return 'tier-low';      // 0-59: Red
          if (rating < 70) return 'tier-below';    // 60-69: Orange  
          if (rating < 80) return 'tier-average';  // 70-79: Yellow
          if (rating < 90) return 'tier-good';     // 80-89: Green
          return 'tier-elite';                     // 90-99: Blue
        }

        // Helper to format rating in a colored box
        function formatRatingBox(rating) {
          if (!rating || rating === 0) return '<span class="rating-box tier-none">-</span>';
          const tierClass = getRatingTierClass(rating);
          return `<span class="rating-box ${tierClass}">${Math.round(rating)}</span>`;
        }

        const html = data.map((team, i) => `
          <div class="team-row">
            <div class="team-rank">${i + 1}</div>
            <div class="team-info">
              <a href="voting-history.html?teamId=${team.id}" style="color:inherit; text-decoration:none;">
                <div class="team-name">${team.username || 'Anonymous'}</div>
                <div class="team-tournament">${team.tournament}</div>
              </a>
            </div>
            ${formatRatingBox(team.madden)}
          </div>
        `).join('') + `
        <a href="/leaderboard" class="see-full-link">View Full Leaderboard</a>
        `;

        container.innerHTML = html;
      } catch (e) {
        console.error('Error loading top teams:', e);
        container.innerHTML = '<div class="error-message">Failed to load data</div>';
      }
    }

    // Show/hide update indicator
    function showUpdateIndicator() {
      const indicator = document.getElementById('recentVotesIndicator');
      if (indicator) indicator.style.visibility = 'visible';
    }
    
    function hideUpdateIndicator() {
      const indicator = document.getElementById('recentVotesIndicator');
      if (indicator) indicator.style.visibility = 'hidden';
    }

    // Load Recent Votes widget
    async function loadRecentVotes() {
      const container = document.getElementById('recentVotesContent');
      if (!container) return;
      
      showUpdateIndicator();
      
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout for recent votes
        
        const res = await fetch('/api/widgets/recent-votes', {
          signal: controller.signal,
          headers: {
            'Cache-Control': 'max-age=10' // Cache for 10 seconds
          }
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch recent votes`);
        const data = await res.json();
        
        if (!data || !data.length) {
          // Smooth transition to "no votes" message
          const currentContent = container.innerHTML;
          const noVotesMessage = '<div class="no-votes-message">No votes yet</div>';
          
          if (currentContent !== noVotesMessage) {
            container.style.opacity = '0.7';
            container.style.transition = 'opacity 0.15s ease';
            
            setTimeout(() => {
              container.innerHTML = noVotesMessage;
              container.style.opacity = '1';
            }, 150);
          }
          return;
        }

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        
        data.forEach((vote) => {
          const voteRow = document.createElement('div');
          voteRow.className = 'vote-row';
          voteRow.innerHTML = `
            <div class="vote-result">
              <span class="winner">${vote.winner_username}</span>
              <span class="vs-text">defeated</span>
              <span class="loser">${vote.loser_username}</span>
            </div>
            <div class="tournament-text">
              <span class="vs-text">${vote.winner_tournament}</span>
            </div>
            <div class="vote-meta">
              <span class="voter">by ${vote.voter_name}</span>
              <span class="time">${vote.time_ago}</span>
            </div>
          `;
          fragment.appendChild(voteRow);
        });
        
        // Smooth update without flickering - only update if content actually changed
        const newContent = Array.from(fragment.children);
        const existingContent = container.querySelectorAll('.vote-row');
        
        // Check if content actually changed by comparing first few items
        let contentChanged = newContent.length !== existingContent.length;
        if (!contentChanged && newContent.length > 0 && existingContent.length > 0) {
          // Compare first item to detect new votes
          const newFirstItem = newContent[0]?.innerHTML || '';
          const existingFirstItem = existingContent[0]?.innerHTML || '';
          contentChanged = newFirstItem !== existingFirstItem;
        }
        
        if (contentChanged) {
          // Smooth transition: fade out, update, fade in
          container.style.opacity = '0.7';
          container.style.transition = 'opacity 0.15s ease';
          
          setTimeout(() => {
            container.innerHTML = '';
            container.appendChild(fragment);
            container.style.opacity = '1';
          }, 150);
        }
        
      } catch (e) {
        console.error('Error loading recent votes:', e);
        if (e.name === 'AbortError') {
          container.innerHTML = '<div class="error-message">Request timed out</div>';
        } else {
          container.innerHTML = '<div class="error-message">Failed to load data</div>';
        }
      } finally {
        hideUpdateIndicator();
      }
    }

    // Auto-update recent votes with smart polling
    let recentVotesInterval;
    let pollAttempts = 0;
    const MAX_POLL_ATTEMPTS = 20; // Keep polling longer for better user experience
    let lastVoteCount = 0;
    
    function startRecentVotesPolling() {
      // Initial load
      loadRecentVotes();
      
      // Aggressive polling for real-time feel: start with 5s, keep responsive
      const initialInterval = 5000;   // 5 seconds for initial fast updates
      const fallbackInterval = 8000;  // 8 seconds after initial activity
      const slowInterval = 15000;     // 15 seconds for background polling
      
      recentVotesInterval = setInterval(() => {
        pollAttempts++;
        
        // Stop polling after max attempts or if page is hidden
        if (pollAttempts >= MAX_POLL_ATTEMPTS || document.hidden) {
          stopRecentVotesPolling();
          return;
        }
        
        // Check if there are new votes before loading
        checkForNewVotes().then(hasNewVotes => {
          if (hasNewVotes) {
            loadRecentVotes();
            // Reset to faster polling if there's activity
            if (pollAttempts > 3) {
              clearInterval(recentVotesInterval);
              recentVotesInterval = setInterval(() => {
                pollAttempts++;
                if (pollAttempts >= MAX_POLL_ATTEMPTS || document.hidden) {
                  stopRecentVotesPolling();
                  return;
                }
                checkForNewVotes().then(hasNew => {
                  if (hasNew) loadRecentVotes();
                });
              }, initialInterval);
            }
          }
        });
        
        // Switch to longer interval after first few attempts
        if (pollAttempts === 3) {
          clearInterval(recentVotesInterval);
          recentVotesInterval = setInterval(() => {
            pollAttempts++;
            if (pollAttempts >= MAX_POLL_ATTEMPTS || document.hidden) {
              stopRecentVotesPolling();
              return;
            }
            checkForNewVotes().then(hasNew => {
              if (hasNew) loadRecentVotes();
            });
          }, fallbackInterval);
        }
        
        // Switch to very slow polling after more attempts
        if (pollAttempts === 6) {
          clearInterval(recentVotesInterval);
          recentVotesInterval = setInterval(() => {
            pollAttempts++;
            if (pollAttempts >= MAX_POLL_ATTEMPTS || document.hidden) {
              stopRecentVotesPolling();
              return;
            }
            checkForNewVotes().then(hasNew => {
              if (hasNew) loadRecentVotes();
            });
          }, slowInterval);
        }
      }, initialInterval);
    }
    
    // Check for new votes without loading full data
    async function checkForNewVotes() {
      try {
        const res = await fetch('/api/widgets/recent-votes-count', {
          headers: { 'Cache-Control': 'no-cache' }
        });
        if (res.ok) {
          const data = await res.json();
          const hasNew = data.count > lastVoteCount;
          lastVoteCount = data.count;
          return hasNew;
        }
      } catch (e) {
        console.warn('Failed to check for new votes:', e);
      }
      return false;
    }

    function stopRecentVotesPolling() {
      if (recentVotesInterval) {
        clearInterval(recentVotesInterval);
        recentVotesInterval = null;
      }
    }

    // Expose loadRecentVotes globally so other scripts can trigger updates
    window.refreshRecentVotes = async () => {
      // Force refresh by bypassing all caches
      const container = document.getElementById('recentVotesContent');
      if (!container) return;
      
      showUpdateIndicator();
      
      try {
        const res = await fetch('/api/widgets/recent-votes', {
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        
        if (res.ok) {
          const data = await res.json();
          if (data && data.length) {
            const fragment = document.createDocumentFragment();
            
            data.forEach((vote) => {
              const voteRow = document.createElement('div');
              voteRow.className = 'vote-row';
              voteRow.innerHTML = `
                <div class="vote-result">
                  <span class="winner">${vote.winner_username}</span>
                  <span class="vs-text">defeated</span>
                  <span class="loser">${vote.loser_username}</span>
                </div>
                <div class="tournament-text">
                  <span class="vs-text">${vote.winner_tournament}</span>
                </div>
                <div class="vote-meta">
                  <span class="voter">by ${vote.voter_name}</span>
                  <span class="time">${vote.time_ago}</span>
                </div>
              `;
              fragment.appendChild(voteRow);
            });
            
            // Smooth update for force refresh - same anti-flicker logic
            const newContent = Array.from(fragment.children);
            const existingContent = container.querySelectorAll('.vote-row');
            
            // Check if content actually changed
            let contentChanged = newContent.length !== existingContent.length;
            if (!contentChanged && newContent.length > 0 && existingContent.length > 0) {
              const newFirstItem = newContent[0]?.innerHTML || '';
              const existingFirstItem = existingContent[0]?.innerHTML || '';
              contentChanged = newFirstItem !== existingFirstItem;
            }
            
            if (contentChanged) {
              container.style.opacity = '0.7';
              container.style.transition = 'opacity 0.15s ease';
              
              setTimeout(() => {
                container.innerHTML = '';
                container.appendChild(fragment);
                container.style.opacity = '1';
              }, 150);
            }
          }
        }
             } catch (e) {
         console.warn('Force refresh failed, falling back to normal load:', e);
         loadRecentVotes();
       } finally {
         hideUpdateIndicator();
       }
       
       // Also reset the vote count to trigger immediate check
       lastVoteCount = 0;
       // Reset poll attempts to keep polling active
       pollAttempts = 0;
     };
    
    // Performance monitoring for recent votes
    async function monitorRecentVotesPerformance() {
      try {
        const startTime = performance.now();
        const res = await fetch('/api/widgets/recent-votes-performance');
        const data = await res.json();
        const endTime = performance.now();
                
        // Log to analytics if available
        if (typeof gtag !== 'undefined') {
          gtag('event', 'timing_complete', {
            name: 'recent_votes_widget',
            value: Math.round(endTime - startTime)
          });
        }
      } catch (e) {
        console.warn('Performance monitoring failed:', e);
      }
    }
    
    // Monitor performance periodically
    setInterval(monitorRecentVotesPerformance, 5 * 60 * 1000); // Every 5 minutes

    // Show/hide draft or pass loading indicator
    function showDraftOrPassIndicator() {
      const indicator = document.getElementById('draftOrPassIndicator');
      if (indicator) indicator.style.visibility = 'visible';
    }
    
    function hideDraftOrPassIndicator() {
      const indicator = document.getElementById('draftOrPassIndicator');
      if (indicator) indicator.style.visibility = 'hidden';
    }

    // Initialize Draft or Pass widget
    function initDraftOrPass() {
      // Set mode to versus for the voting functionality
      if (typeof currentMode !== 'undefined') {
        currentMode = 'versus';
      }
      
      // Custom fetch that preserves skeleton loading for homepage widget
      const container = document.getElementById("teamsContainer");
      if (!container) return;
      
      // Show loading indicator
      showDraftOrPassIndicator();
      
      if (typeof fetch === 'function') {
        fetch("/teams")
          .then(res => res.json())
          .then(data => {
            // Process teams data (simplified version of what fetchTeams does)
            if (typeof teams !== 'undefined' && typeof shuffle === 'function') {
              teams = shuffle(data.teams);
              if (data.tournaments) teamTournaments = data.tournaments;
              if (data.usernames) teamUsernames = data.usernames;
              if (data.userIds) teamUserIds = data.userIds;
              if (data.totals) {
                teamVoteTotals = {};
                Object.entries(data.totals).forEach(([tid, t]) => {
                  teamVoteTotals[tid] = (t.wins || 0) + (t.losses || 0);
                });
              }
              if (typeof currentUserId !== 'undefined' && currentUserId) {
                myTeamIds = Object.keys(teamUserIds || {}).filter(tid => teamUserIds[tid] === currentUserId);
              } else {
                myTeamIds = [];
              }
              currentIndex = 0;
              
              // Render the teams (this will replace skeleton)
              if (typeof renderVersus === 'function') {
                renderVersus();
              }
            }
          })
          .catch(err => {
            console.error('Failed to load teams for homepage widget:', err);
            if (container) {
              container.innerHTML = '<div class="error-message">Failed to load teams</div>';
            }
          })
          .finally(() => {
            // Hide loading indicator when done
            hideDraftOrPassIndicator();
          });
      }
    }

    // Simple notification loading function for index page
    async function loadNotificationsForIndex() {
      const notificationList = document.getElementById('notificationList');
      if (!notificationList) return;

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        if (!res.ok) {
          notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];

        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = notifications.map(notification => {
          const timeAgo = formatTimeAgo(new Date(notification.created_at));
          let msgHtml = notification.message;
          if (notification.type === 'versus_vote' && notification.related_team_id) {
            msgHtml = msgHtml.replace('your team', `<a href=\"voting-history.html?teamId=${notification.related_team_id}\" style=\"color:#58a6ff;text-decoration:none;\">your team</a>`);
            if (notification.opponent_team_id) {
              const idx = msgHtml.lastIndexOf('against ');
              if (idx !== -1) {
                const before = msgHtml.substring(0, idx + 8);
                const oppName = msgHtml.substring(idx + 8);
                const oppLink = `<span class=\"desktop-opponent-link\" data-team-id=\"${notification.opponent_team_id}\" style=\"color:#58a6ff;cursor:pointer;text-decoration:none;\">${oppName}</span>`;
                msgHtml = before + oppLink;
              }
            }
          }
          return `
            <div class=\"notification-item ${notification.is_read ? '' : 'unread'}\" data-notification-id=\"${notification.id}\">\n              <div class=\"notification-message\">${msgHtml}</div>\n              <div class=\"notification-time\">${timeAgo}</div>\n            </div>`;
        }).join('');

        // Attach opponent link click
        document.querySelectorAll('.desktop-opponent-link').forEach(link=>{
          link.addEventListener('click', async (e)=>{
            e.stopPropagation();
            const teamId = link.getAttribute('data-team-id');
            if(!teamId) return;
            try {
              const r = await fetch(`/team-meta/${teamId}`);
              const meta = await r.json();
              if(meta && meta.username){
                window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
              } else {
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            }catch(err){
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          });
        });

        // Mark notifications as read when clicked
        document.querySelectorAll('.notification-item').forEach(item => {
          item.addEventListener('click', async () => {
            const notificationId = item.dataset.notificationId;
            if (notificationId && !item.classList.contains('read')) {
              try {
                await fetch('/notifications/read', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ notificationIds: [parseInt(notificationId)] })
                });
                item.classList.remove('unread');
                item.classList.add('read');
                
                // Update notification count if function exists
                if (typeof updateNotificationCount === 'function') {
                  updateNotificationCount();
                }
              } catch (e) {
                console.error('Failed to mark notification as read:', e);
              }
            }
          });
        });

      } catch (e) {
        console.error('Failed to load notifications:', e);
        notificationList.innerHTML = '<div class="no-notifications">Failed to load notifications</div>';
      }
    }

    // ---- Notification helpers (badge + polling) ----

    function updateNotificationBadge(count) {
      const desktopBadge = document.getElementById('notificationBadge');
      if (desktopBadge) {
        if (count > 0) {
          desktopBadge.textContent = count > 99 ? '99+' : count;
          desktopBadge.style.display = 'inline';
        } else {
          desktopBadge.style.display = 'none';
        }
      }

      const mobileBadge = document.getElementById('mobileNotificationBadge');
      if (mobileBadge) {
        if (count > 0) {
          mobileBadge.textContent = count > 99 ? '99+' : count;
          mobileBadge.style.display = 'inline';
        } else {
          mobileBadge.style.display = 'none';
        }
      }
    }

    async function updateNotificationCount() {
      try {
        const res = await fetch('/notifications/count');
        if (res.ok) {
          const data = await res.json();
          updateNotificationBadge(data.count || 0);
        }
      } catch(err) { console.error('Notif count fetch error', err); }
    }

    let notifPoll = null;

    function startNotificationPolling() {
      updateNotificationCount();
      if (notifPoll) clearInterval(notifPoll);
      notifPoll = setInterval(updateNotificationCount, 30000);
    }

    function stopNotificationPolling() {
      if (notifPoll) { clearInterval(notifPoll); notifPoll = null; }
    }

    // ---- Mobile Notification Functions ----
    function showMobileNotifications() {
      // Create mobile notification overlay if it doesn't exist
      let overlay = document.getElementById('mobileNotificationOverlay');
      if (!overlay) {
        overlay = createMobileNotificationOverlay();
        document.body.appendChild(overlay);
      }
      
      // Show the overlay
      overlay.style.display = 'flex';
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      
      // Load notifications
      loadMobileNotifications();
    }

    function hideMobileNotifications() {
      const overlay = document.getElementById('mobileNotificationOverlay');
      if (overlay) {
        overlay.style.display = 'none';
        document.body.style.overflow = ''; // Restore scrolling
      }
    }

    function createMobileNotificationOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'mobileNotificationOverlay';
      overlay.className = 'mobile-notification-overlay';
      
      overlay.innerHTML = `
        <div class="mobile-notification-content">
          <div class="mobile-notification-header">
            <h3>Notifications</h3>
            <div class="mobile-notification-actions">
              <button id="mobileMarkAllRead" class="mobile-mark-all-read-btn">Mark all read</button>
              <button id="closeMobileNotifications" class="mobile-close-notifications-btn">‚úñ</button>
            </div>
          </div>
          <div id="mobileNotificationList" class="mobile-notification-list">
            <div class="loading">Loading notifications...</div>
          </div>
        </div>
      `;

      // Add event listeners
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          hideMobileNotifications();
        }
      });

      overlay.querySelector('#closeMobileNotifications').addEventListener('click', hideMobileNotifications);
      overlay.querySelector('#mobileMarkAllRead').addEventListener('click', markAllNotificationsAsReadMobile);
      
      return overlay;
    }

    async function loadMobileNotifications() {
      const notificationList = document.getElementById('mobileNotificationList');
      if (!notificationList) return;

      notificationList.innerHTML = '<div class="loading">Loading notifications...</div>';

      try {
        const res = await fetch('/notifications');
        
        if (!res.ok) {
          if (res.status === 401) {
            notificationList.innerHTML = '<div class="no-notifications">Please log in to view notifications</div>';
          } else {
            notificationList.innerHTML = `<div class="no-notifications">Failed to load notifications (${res.status})</div>`;
          }
          return;
        }

        const data = await res.json();
        const notifications = data.notifications || [];
        
        if (notifications.length === 0) {
          notificationList.innerHTML = '<div class="no-notifications">No notifications yet</div>';
          return;
        }

        notificationList.innerHTML = '';
        notifications.forEach((notification, index) => {
          try {
            const item = createMobileNotificationItem(notification);
            notificationList.appendChild(item);
          } catch (itemError) {
            console.error(`Error creating mobile notification item ${index}:`, itemError);
          }
        });
      } catch (e) {
        console.error('Failed to load mobile notifications:', e);
        notificationList.innerHTML = `<div class="no-notifications">Network error: ${e.message}</div>`;
      }
    }

    function createMobileNotificationItem(notification) {
      const item = document.createElement('div');
      item.className = `mobile-notification-item ${notification.is_read ? '' : 'unread'}`;
      item.dataset.notificationId = notification.id;

      const timeAgo = formatTimeAgo(new Date(notification.created_at));
      
      let messageHTML = notification.message;
      
      if (notification.type === 'versus_vote' && notification.related_team_id) {
        const teamLink = `<a href="voting-history.html?teamId=${notification.related_team_id}" style="color: #58a6ff; text-decoration: none;">your team</a>`;
        messageHTML = messageHTML.replace('your team', teamLink);
        
        if (notification.opponent_team_id) {
          const againstIndex = messageHTML.lastIndexOf('against ');
          if (againstIndex !== -1) {
            const beforeAgainst = messageHTML.substring(0, againstIndex + 8);
            const opponentName = messageHTML.substring(againstIndex + 8);
            
            if (opponentName.trim()) {
              const opponentLink = `<span class="mobile-opponent-link" data-team-id="${notification.opponent_team_id}" style="color: #58a6ff; cursor: pointer; text-decoration: underline;">${opponentName}</span>`;
              messageHTML = beforeAgainst + opponentLink;
            }
          }
        }
      }
      
      item.innerHTML = `
        <div class="mobile-notification-message">${messageHTML}</div>
        <div class="mobile-notification-time">${timeAgo}</div>
      `;

      // Add click handlers for opponent links
      const opponentLinks = item.querySelectorAll('.mobile-opponent-link');
      opponentLinks.forEach(link => {
        link.addEventListener('click', async (e) => {
          e.stopPropagation();
          const teamId = link.getAttribute('data-team-id');
          if (teamId) {
            try {
              const res = await fetch(`/team-meta/${teamId}`);
              const meta = await res.json();
              if (meta.username) {
                window.location.href = `profile.html?user=${encodeURIComponent(meta.username)}`;
              } else {
                window.location.href = `voting-history.html?teamId=${teamId}`;
              }
            } catch (error) {
              console.error('Failed to fetch opponent info:', error);
              window.location.href = `voting-history.html?teamId=${teamId}`;
            }
          }
        });
      });

      // Mark as read when clicked (but not when clicking links)
      item.addEventListener('click', async (e) => {
        if (e.target.tagName === 'A' || e.target.classList.contains('mobile-opponent-link')) {
          return;
        }
        
        if (!notification.is_read) {
          try {
            await fetch('/notifications/read', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ notificationIds: [parseInt(notification.id)] })
            });
            item.classList.remove('unread');
            item.classList.add('read');
            updateNotificationCount();
          } catch (error) {
            console.error('Failed to mark notification as read:', error);
          }
        }
      });

      return item;
    }

    async function markAllNotificationsAsReadMobile() {
      try {
        const res = await fetch('/notifications/read-all', {
          method: 'POST'
        });
        if (res.ok) {
          // Immediately update the badge to 0 for instant feedback
          updateNotificationBadge(0);
          
          // Reload the notification list
          await loadMobileNotifications();
          
          // Wait a moment for database to update, then refresh count
          setTimeout(async () => {
            await updateNotificationCount();
          }, 500);
        } else {
          console.error('Failed to mark all mobile notifications as read:', res.status, res.statusText);
        }
      } catch (e) {
        console.error('Failed to mark all mobile notifications as read:', e);
      }
    }

    // === INITIALISE MOBILE NOTIFICATION BUTTON ===
    function setupMobileNotifications() {
      const btn = document.getElementById('mobileNotificationBtn');
      if (!btn) {
        return;
      }

      // Remove previous listeners by cloning
      const clone = btn.cloneNode(true);
      btn.parentNode.replaceChild(clone, btn);

      clone.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();

        try {
          const res = await fetch('/me');
          const auth = await res.json();
          if (auth && auth.user) {
            // Ensure global currentUserId is set so script.js variant works if it overwrote ours
            window.currentUserId = auth.user.id;
            // Prefer our local overlay without login guard if script.js one blocks
            if (typeof showMobileNotifications === 'function') {
              showMobileNotifications();
            } else {
              console.warn('[Index] showMobileNotifications not defined');
            }
          } else {
            alert('Please log in to view notifications');
          }
        } catch (err) {
          console.error('[Index] Auth check failed', err);
          alert('Please log in to view notifications');
        }
      });
    }

    // Always (re)run when header injected
    document.addEventListener('headerLoaded', () => {
      // Delay slightly to ensure DOM tree updated
      setTimeout(setupMobileNotifications, 50);
    });

    // Simple time ago formatting function
    function formatTimeAgo(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);

      if (diffSecs < 60) return `${diffSecs}s ago`;
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      return `${diffDays}d ago`;
    }

    // Progressive loading with intersection observer
    let widgetObserver;
    let loadedWidgets = new Set();
    
    function initLazyLoading() {
      // Create intersection observer for lazy loading widgets (excluding critical widgets)
      widgetObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !loadedWidgets.has(entry.target.dataset.widget)) {
            const widgetType = entry.target.dataset.widget;
            loadWidget(widgetType);
            loadedWidgets.add(widgetType);
            widgetObserver.unobserve(entry.target);
          }
        });
      }, {
        rootMargin: '50px 0px', // Start loading 50px before widget comes into view
        threshold: 0.1
      });
      
      // Observe all widgets except critical ones that load immediately
      document.querySelectorAll('[data-widget]').forEach(widget => {
        const widgetType = widget.dataset.widget;
        // Skip widgets that are loaded as critical widgets
        if (!loadedWidgets.has(widgetType)) {
          widgetObserver.observe(widget);
        }
      });
    }
    
    function loadWidget(widgetType) {
      switch(widgetType) {
        case 'top-drafters':
          loadTopDrafters();
          break;
        case 'top-teams':
          loadTopTeams();
          break;
        case 'recent-votes':
          loadRecentVotes();
          startRecentVotesPolling();
          break;
        case 'draft-or-pass':
          initDraftOrPass();
          break;
      }
    }
    
    // Load critical widgets immediately (above the fold and layout-critical)
    function loadCriticalWidgets() {
      // Load top drafters immediately as it's likely above the fold
      loadTopDrafters();
      loadedWidgets.add('top-drafters');
      
      // Load draft or pass widget immediately to prevent layout jump and smooth UX
      initDraftOrPass();
      loadedWidgets.add('draft-or-pass');
    }
    
    // Performance monitoring
    function logPerformanceMetric(name, startTime) {
      const duration = performance.now() - startTime;
      
      // Send to analytics if available
      if (typeof gtag !== 'undefined') {
        gtag('event', 'timing_complete', {
          name: name,
          value: Math.round(duration)
        });
      }
    }
    
    // Initialize page
    document.addEventListener('DOMContentLoaded', () => {
      const pageLoadStart = performance.now();
      
      // Load critical content immediately
      loadCriticalWidgets();

      // Run mobile notification setup in case header already present
      setTimeout(setupMobileNotifications, 100);
      
      // Set up lazy loading for other widgets
      initLazyLoading();
      
      // Log initial page load performance
      setTimeout(() => {
        logPerformanceMetric('initial_page_load', pageLoadStart);
      }, 100);
      
      // Pause polling when page is not visible to save resources
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopRecentVotesPolling();
          stopNotificationPolling();
        } else {
          // Only restart polling if recent votes widget is loaded
          if (loadedWidgets.has('recent-votes')) {
            startRecentVotesPolling();
          }
          startNotificationPolling();
        }
      });

      // Wait for header to load before accessing header elements
      function initHeaderDependentFeatures() {
        // Mobile menu toggle
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const mobileNav = document.getElementById('mobileNav');
        
        if (mobileMenuToggle && mobileNav) {
          mobileMenuToggle.addEventListener('click', () => {
            mobileNav.classList.toggle('active');
            mobileMenuToggle.classList.toggle('active');
          });
          
          // Close mobile menu when clicking on a link
          document.querySelectorAll('.mobile-nav-link').forEach(link => {
            link.addEventListener('click', () => {
              mobileNav.classList.remove('active');
              mobileMenuToggle.classList.remove('active');
            });
          });
        }
        
        // Start voting button
        const startVotingBtn = document.getElementById('startVotingBtn');
        if (startVotingBtn) {
          startVotingBtn.addEventListener('click', () => {
            window.location.href = '/draftorpass';
          });
        }
      }

      // Listen for auth state resolution from header.js
      document.addEventListener('authStateResolved', (event) => {
        const { isLoggedIn, user } = event.detail;
        
        if (isLoggedIn) {
          const displayName = user.display_name || user.email || 'User';
          
          // Start badge polling (non-header dependent)
          startNotificationPolling();
          


          // Set up header-dependent features after auth check
          document.addEventListener('headerLoaded', () => {
            // Update desktop user controls
            const userLabel = document.getElementById('userLabel');
            if (userLabel) userLabel.textContent = displayName;
            
            // Set up notification bell click handler
            const notificationBell = document.getElementById('notificationBell');
            if (notificationBell) {
              notificationBell.addEventListener('click', (e) => {
                e.stopPropagation();
                const notificationDropdown = document.getElementById('notificationDropdown');
                const userMenu = document.getElementById('userMenu');
                
                if (notificationDropdown) {
                  const isVisible = notificationDropdown.style.display !== 'none';
                  
                  if (isVisible) {
                    notificationDropdown.style.display = 'none';
                  } else {
                    // Hide user menu if open
                    if (userMenu) userMenu.style.display = 'none';
                    notificationDropdown.style.display = 'block';
                    
                    // Load notifications
                    loadNotificationsForIndex();
                  }
                }
              });
            }
            
            // Add mobile notification click handler for all users
            const mobileNotificationBtn = document.getElementById('mobileNotificationBtn');
            if (mobileNotificationBtn) {
              // Remove any existing handlers to avoid duplicates
              const newBtn = mobileNotificationBtn.cloneNode(true);
              mobileNotificationBtn.parentNode.replaceChild(newBtn, mobileNotificationBtn);
              
              newBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                try {
                  const authRes = await fetch('/me');
                  const authData = await authRes.json();
                  
                  if (authData.user) {
                    showMobileNotifications();
                  } else {
                    alert('Please log in to view notifications');
                  }
                } catch (e) {
                  console.error('Auth check failed:', e);
                  alert('Please log in to view notifications');
                }
              });
            }
            
            // Initialize header-dependent features for all users
            initHeaderDependentFeatures();
          });
        } else {
          // Not logged in - still need to initialize header features
          document.addEventListener('headerLoaded', () => {
            // Add mobile notification click handler for all users (even when not logged in)
            const mobileNotificationBtn = document.getElementById('mobileNotificationBtn');
            if (mobileNotificationBtn) {
              // Remove any existing handlers to avoid duplicates
              const newBtn = mobileNotificationBtn.cloneNode(true);
              mobileNotificationBtn.parentNode.replaceChild(newBtn, mobileNotificationBtn);
              
              newBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                try {
                  const authRes = await fetch('/me');
                  const authData = await authRes.json();
                  
                  if (authData.user) {
                    showMobileNotifications();
                  } else {
                    alert('Please log in to view notifications');
                  }
                } catch (e) {
                  console.error('Auth check failed:', e);
                  alert('Please log in to view notifications');
                }
              });
            }
            
            initHeaderDependentFeatures();
          });
        }
      });

      // Set up header-dependent features that require header elements
      // This will be called after header is loaded
      document.addEventListener('headerLoaded', () => {
        // Logout functionality
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
          logoutBtn.addEventListener('click', async () => {
            await fetch('/logout', { method: 'POST' });
            window.location.reload();
          });
        }

        // Profile button - go directly to profile page
        const userGear = document.getElementById('userGear');
        if (userGear) {
          userGear.addEventListener('click', (e) => {
            if (userGear.style.display !== 'none') {
              window.location.href = '/profile.html';
            }
          });
        }
        
        // Mark all notifications as read button
        const markAllReadBtn = document.getElementById('markAllRead');
        if (markAllReadBtn) {
          markAllReadBtn.addEventListener('click', async () => {
            try {
              const res = await fetch('/notifications/read-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              });
              
              if (res.ok) {
                // Mark all notification items as read visually
                document.querySelectorAll('.notification-item.unread').forEach(item => {
                  item.classList.remove('unread');
                  item.classList.add('read');
                });
                
                // Update notification count badge
                if (typeof updateNotificationCount === 'function') {
                  updateNotificationCount();
                }
                
              } else {
                console.error('Failed to mark all notifications as read');
              }
            } catch (e) {
              console.error('Error marking all notifications as read:', e);
            }
          });
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.user-controls')) {
            const userMenu = document.getElementById('userMenu');
            const notificationDropdown = document.getElementById('notificationDropdown');
            if (userMenu) userMenu.style.display = 'none';
            if (notificationDropdown) notificationDropdown.style.display = 'none';
          }
        });
      });
    });
  </script>

  <footer class="legal-footer">
    <div class="footer-content">
      <div class="social-links">
        <a href="https://x.com/DraftrPass" target="_blank" rel="noopener noreferrer" title="Follow us on X">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://discord.gg/Y7hyQsfDQx" target="_blank" rel="noopener noreferrer" title="Join our Discord">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.566 18.566 0 0 0-5.487 0 12.36 12.36 0 0 0-.617-1.23A.077.077 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.07.07 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20.03 20.03 0 0 0 5.993 2.98.078.078 0 0 0 .084-.026 13.83 13.83 0 0 0 1.226-1.963.074.074 0 0 0-.041-.104 13.201 13.201 0 0 1-1.872-.878.075.075 0 0 1-.008-.125c.126-.093.252-.19.372-.287a.075.075 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.075.075 0 0 1 .079.009c.12.098.246.195.372.288a.075.075 0 0 1-.006.125c-.598.344-1.22.635-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.077.077 0 0 0 .084.028 19.963 19.963 0 0 0 6.002-2.981.076.076 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028zM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38z"/>
          </svg>
        </a>
      </div>
      <div class="legal-links">
        <a href="privacy.html" target="_blank">Privacy Policy</a>
        <a href="terms.html" target="_blank">Terms of Service</a>
      </div>
    </div>
  </footer>
</body>
</html>
